<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Sight Words Trainer ‚Äî Rainbow Levels</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <style>
    :root{
      --bg:#0f1115;
      --fg:#e6e6e6;
      --muted:#9aa3ad;
      --panel:#151922;
      --accent:#6ea8fe;
      --success:#22c55e;
      --danger:#ef4444;
      --gold:#ffd166;
      --leftTint: rgba(239,68,68,0.24);
      --rightTint: rgba(16,185,129,0.22);
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:linear-gradient(180deg,#0f1115,#0b0e14);
      color:var(--fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, "Helvetica Neue", Arial, sans-serif;
      -webkit-font-smoothing:antialiased; text-rendering:optimizeLegibility;
    }
    .app{display:flex; flex-direction:column; height:100%;}
    header{
      display:flex; align-items:flex-start; justify-content:center; gap:8px;
      padding:12px 14px; background:rgba(255,255,255,0.03);
      border-bottom:1px solid rgba(255,255,255,0.06);
      flex-wrap:wrap;
    }
    .header-top {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }
    .header-info {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
      flex-wrap: wrap;
    }
    @media (max-width: 768px) {
      header {
        flex-direction: column;
        align-items: stretch;
        gap: 12px;
        padding: 16px 14px;
      }
      .header-info {
        justify-content: center;
        gap: 6px;
      }
      .badge-row {
        justify-content: center;
      }
    }
    .phase-badge{
      font-size:12px; padding:4px 10px; border-radius:999px;
      background:rgba(110,168,254,0.12); color:var(--accent);
      border:1px solid rgba(110,168,254,0.3); letter-spacing:.3px; white-space:nowrap;
    }
    .student{font-weight:800; font-size:12px; color:#cbd5e1; opacity:.9}
    .controls{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    @media (max-width: 768px) {
      .controls {
        justify-content: center;
        gap: 6px;
      }
      .controls button {
        font-size: 12px;
        padding: 6px 10px;
      }
    }
    button{
      background:var(--panel); color:var(--fg);
      border:1px solid rgba(255,255,255,0.10); border-radius:10px;
      padding:8px 12px; font-weight:700; cursor:pointer; font-size:14px;
    }
    button:hover{border-color:rgba(255,255,255,0.25)}
    .ghost{background:transparent;}
    .badge-row{display:flex; align-items:center; gap:6px; flex-wrap:wrap}
    .emoji-badge{font-size:28px; line-height:1; filter:drop-shadow(0 2px 8px rgba(0,0,0,.4))}
    .level-button{
      padding:10px 16px; border-radius:12px; border:2px solid rgba(255,255,255,0.2); 
      background:rgba(255,255,255,0.06); cursor:pointer; transition:all 0.2s ease;
      display:flex; flex-direction:column; align-items:center; gap:4px;
      width:100%; max-width:400px;
    }
    .level-button:hover{background:rgba(255,255,255,0.10); transform:translateY(-1px)}
    .level-button-top{display:flex; align-items:center; gap:8px; font-weight:800; font-size:16px; color:var(--fg)}
    .level-button-bottom{font-size:10px; color:var(--muted); font-weight:600}
    .dot{width:12px; height:12px; border-radius:50%}
    .dot.rainbow{
      background:linear-gradient(45deg, #ef4444, #f97316, #eab308, #22c55e, #3b82f6, #a855f7, #ec4899, #38bdf8);
      background-size:200% 200%; animation:rainbowFlow 3s ease infinite;
    }
    
    .profile-button{
      padding:8px 16px; border-radius:12px; border:2px solid rgba(255,255,255,0.2);
      background:rgba(255,255,255,0.06); cursor:pointer; transition:all 0.2s ease;
      width:100%; max-width:400px;
    }
    .profile-button:hover{background:rgba(255,255,255,0.10); transform:translateY(-1px)}
    .profile-button-content{display:flex; flex-direction:column; align-items:center; gap:6px}
    .student-name{font-weight:800; font-size:16px; color:var(--fg)}
    .badge-row-inline{display:flex; gap:4px; flex-wrap:wrap; justify-content:center}
    .word-area{
      flex:1; display:flex; align-items:center; justify-content:center;
      position:relative; overflow:hidden;
    }
    .word{
      font-size: clamp(64px, 12vw, 160px);
      font-weight: 900; letter-spacing:1px; line-height:1.0;
      text-align:center; padding:0 16px; user-select:none;
      text-shadow: 0 8px 26px rgba(0,0,0,0.5);
    }
    .tapzones{ position:absolute; inset:0; display:grid; grid-template-columns:1fr 1fr; }
    .zone{
      position:relative; display:flex; align-items:flex-end; justify-content:center; padding:16px;
      -webkit-tap-highlight-color: transparent;
    }
    .zone:active{filter:brightness(1.06)}
    .zone-left{background:linear-gradient(180deg, var(--leftTint), rgba(0,0,0,0))}
    .zone-right{background:linear-gradient(180deg, var(--rightTint), rgba(0,0,0,0))}
    .zone-label{
      pointer-events:none; user-select:none; font-weight:800; font-size:14px; letter-spacing:.2px;
      padding:7px 11px; border-radius:999px; margin-bottom:12px; opacity:.98;
      border:1px solid rgba(255,255,255,0.2);
    }
    .zone-left .zone-label{background:rgba(239,68,68,0.30); color:#ffe2e2}
    .zone-right .zone-label{background:rgba(16,185,129,0.30); color:#e0fff5}
    .tip{
      position:absolute; bottom:20px; left:50%; transform:translateX(-50%);
      color:#cbd5e1; font-size:12px; text-align:center; opacity:.9;
      background:rgba(15,23,42,0.6); padding:6px 10px; border-radius:999px;
      border:1px solid rgba(255,255,255,0.08);
    }
    @media (max-width: 768px) {
      .tip {
        bottom: 28px;
        font-size: 11px;
      }
    }
    footer{
      padding:16px 14px 20px 14px; background:rgba(255,255,255,0.03);
      border-top:1px solid rgba(255,255,255,0.06);
    }
    @media (max-width: 768px) {
      footer {
        padding: 20px 14px 32px 14px; /* Extra bottom padding for mobile browsers */
      }
    }
    .progress{ display:flex; flex-direction:column; gap:14px; align-items:center }
    .bar-wrap{ display:flex; gap:10px; align-items:center; justify-content:center; width:100%; }
    .bar-label{ font-size:16px; color:var(--fg); min-width:120px; font-weight:800; letter-spacing:.3px }
    .bar{
      position:relative; height:30px; background:#0b0e14; border:1px solid rgba(255,255,255,0.10); border-radius:999px; overflow:hidden; flex:1;
    }
    .bar > span{position:absolute; left:0; top:0; bottom:0; width:0%; background:linear-gradient(90deg, #2d6fea, #5ff3b1)}
    #progressFill{position:absolute; left:0; top:0; bottom:0; width:0%; background:linear-gradient(90deg, #2d6fea, #5ff3b1); transition:width 0.3s ease;}
    .stats{display:flex; gap:10px; justify-content:space-between; align-items:center; font-size:16px; color:var(--fg); flex-wrap:wrap; font-weight:800; margin-top:8px}
    .reset-level-footer{
      background:transparent; color:var(--muted); border:1px solid rgba(255,255,255,0.1);
      padding:6px 12px; font-size:12px; font-weight:600; cursor:pointer; border-radius:6px;
      transition:all 0.2s ease;
    }
    .reset-level-footer:hover{color:var(--fg); border-color:rgba(255,255,255,0.25)}
    .pill{padding:4px 8px; border-radius:999px; border:1px solid rgba(255,255,255,0.07); background:rgba(255,255,255,0.03)}
    /* overlay / modal base */
    .overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:30;
      background:rgba(0,0,0,0.6);
    }
    .overlay.show{display:flex;}
    .card{
      width:min(720px, 92vw);
      background:linear-gradient(180deg, #0f141f, #0b1019);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px; padding:18px;
      box-shadow:0 20px 60px rgba(0,0,0,0.45); color:var(--fg);
    }
    .card h2{margin:6px 0 4px 0}
    .muted{color:var(--muted); margin-top:4px}
    .row{display:flex; gap:10px; flex-wrap:wrap}
    .btn-row{display:flex; gap:10px; justify-content:flex-end; flex-wrap:wrap; margin-top:12px}
    .fun-wrap{display:flex; gap:14px; align-items:center; margin:6px 0 10px 0}
    .fun-emoji{font-size:46px; filter:drop-shadow(0 8px 20px rgba(0,0,0,.35))}
    .level-grid{display:grid; grid-template-columns:repeat(3, 1fr); gap:10px; margin-top:10px}
    .level-btn{
      display:flex; flex-direction:column; align-items:center; gap:10px;
      padding:12px; border-radius:14px; border:1px solid rgba(255,255,255,0.12); cursor:pointer;
      background:rgba(255,255,255,0.04);
    }
    .level-dot{width:26px; height:26px; border-radius:50%; border:2px solid rgba(255,255,255,0.28)}
    .level-btn span{font-weight:800}
    .level-btn small{color:var(--muted)}
    .success{ position:fixed; inset:0; background:rgba(0,0,0,0.75); display:none; align-items:center; justify-content:center; z-index:25 }
    .success.show{display:flex;}
    .success-card{
      background:linear-gradient(180deg,#122017,#0c160f);
      border:1px solid rgba(46, 255, 170, 0.25);
      color:#d7ffe9; padding:26px; border-radius:16px; max-width:520px; text-align:center;
      box-shadow:0 20px 60px rgba(0,0,0,0.45);
    }
    .trophy{ width:120px; height:120px; margin:0 auto 14px auto; display:block; filter:drop-shadow(0 8px 20px rgba(46,255,170,.25)) }
    input[type="text"]{
      background:#0b1220; color:#e6e6e6; border:1px solid rgba(255,255,255,0.15);
      border-radius:10px; padding:10px 12px; width:100%; font-size:14px;
    }
    .center{display:flex; align-items:center; justify-content:center}
    
    /* Badge Animation Styles */
    .badge-celebration{
      position:fixed; inset:0; z-index:50; pointer-events:none;
      display:none; align-items:center; justify-content:center;
    }
    .badge-celebration.show{display:flex;}
    .badge-burst{
      position:relative; animation:badgePop 1.8s cubic-bezier(0.68,-0.55,0.265,1.55);
    }
    .badge-burst .emoji-badge{
      font-size:200px; filter:drop-shadow(0 20px 50px rgba(0,0,0,.8));
      animation:badgeFloat 2s ease-in-out infinite, badgeFadeOut 0.8s ease-out 1.8s forwards;
    }
    
    /* Confetti Styles */
    .confetti-container{
      position:absolute; inset:0; overflow:hidden; pointer-events:none;
    }
    .confetti-piece{
      position:absolute; width:8px; height:8px; border-radius:2px;
      animation:confettiFall 3s linear forwards;
    }
    .confetti-piece:nth-child(odd){border-radius:50%;}
    .confetti-piece:nth-child(3n){width:6px; height:12px; border-radius:3px;}
    .confetti-piece:nth-child(5n){width:10px; height:4px; border-radius:2px;}
    
    /* Confetti Colors */
    .confetti-piece:nth-child(1){background:#ff6b6b; left:10%; animation-delay:0s;}
    .confetti-piece:nth-child(2){background:#4ecdc4; left:20%; animation-delay:0.1s;}
    .confetti-piece:nth-child(3){background:#45b7d1; left:30%; animation-delay:0.2s;}
    .confetti-piece:nth-child(4){background:#f9ca24; left:40%; animation-delay:0.3s;}
    .confetti-piece:nth-child(5){background:#6c5ce7; left:50%; animation-delay:0.4s;}
    .confetti-piece:nth-child(6){background:#fd79a8; left:60%; animation-delay:0.5s;}
    .confetti-piece:nth-child(7){background:#00b894; left:70%; animation-delay:0.6s;}
    .confetti-piece:nth-child(8){background:#e17055; left:80%; animation-delay:0.7s;}
    .confetti-piece:nth-child(9){background:#74b9ff; left:90%; animation-delay:0.8s;}
    .confetti-piece:nth-child(10){background:#fd79a8; left:15%; animation-delay:0.9s;}
    .confetti-piece:nth-child(11){background:#fdcb6e; left:25%; animation-delay:1.0s;}
    .confetti-piece:nth-child(12){background:#6c5ce7; left:35%; animation-delay:1.1s;}
    .confetti-piece:nth-child(13){background:#00b894; left:45%; animation-delay:1.2s;}
    .confetti-piece:nth-child(14){background:#e84393; left:55%; animation-delay:1.3s;}
    .confetti-piece:nth-child(15){background:#00cec9; left:65%; animation-delay:1.4s;}
    .confetti-piece:nth-child(16){background:#fdcb6e; left:75%; animation-delay:1.5s;}
    .confetti-piece:nth-child(17){background:#a29bfe; left:85%; animation-delay:1.6s;}
    .confetti-piece:nth-child(18){background:#ff7675; left:95%; animation-delay:1.7s;}
    .confetti-piece:nth-child(19){background:#00b894; left:5%; animation-delay:1.8s;}
    .confetti-piece:nth-child(20){background:#fdcb6e; left:12%; animation-delay:1.9s;}
    .confetti-piece:nth-child(21){background:#6c5ce7; left:22%; animation-delay:2.0s;}
    .confetti-piece:nth-child(22){background:#fd79a8; left:32%; animation-delay:2.1s;}
    .confetti-piece:nth-child(23){background:#00cec9; left:42%; animation-delay:2.2s;}
    .confetti-piece:nth-child(24){background:#e17055; left:52%; animation-delay:2.3s;}
    .confetti-piece:nth-child(25){background:#74b9ff; left:62%; animation-delay:2.4s;}
    
    @keyframes badgePop{
      0%{transform:scale(0) rotate(0deg); opacity:0;}
      50%{transform:scale(4) rotate(360deg); opacity:1;}
      70%{transform:scale(4.2) rotate(360deg); opacity:1;}
      85%{transform:scale(0.85) rotate(360deg); opacity:1;}
      100%{transform:scale(1) rotate(360deg); opacity:1;}
    }
    @keyframes badgeFadeOut{
      0%{opacity:1;}
      100%{opacity:0;}
    }
    @keyframes badgeFloat{
      0%,100%{transform:translateY(0px) scale(1);}
      25%{transform:translateY(-15px) scale(1.05);}
      50%{transform:translateY(-20px) scale(1.1);}
      75%{transform:translateY(-10px) scale(1.02);}
    }
    @keyframes confettiFall{
      0%{transform:translateY(0px) rotate(0deg) translateX(0px); opacity:1;}
      25%{transform:translateY(25vh) rotate(180deg) translateX(20px); opacity:0.8;}
      50%{transform:translateY(50vh) rotate(360deg) translateX(-15px); opacity:0.6;}
      75%{transform:translateY(75vh) rotate(540deg) translateX(10px); opacity:0.4;}
      100%{transform:translateY(120vh) rotate(720deg) translateX(-5px); opacity:0;}
    }
    
    /* Profile Modal Styles */
    .profile-overlay{
      position:fixed; inset:0; display:none; align-items:center; justify-content:center; z-index:35;
      background:rgba(0,0,0,0.7);
    }
    .profile-overlay.show{display:flex;}
    .profile-card{
      width:min(600px, 90vw); max-height:80vh; overflow-y:auto;
      background:linear-gradient(180deg, #0f141f, #0b1019);
      border:1px solid rgba(255,255,255,0.12);
      border-radius:16px; padding:24px;
      box-shadow:0 20px 60px rgba(0,0,0,0.5);
      position:relative;
    }
    .profile-close-btn{
      position:absolute; top:16px; right:16px;
      background:transparent; color:var(--muted); border:none;
      font-size:24px; cursor:pointer; padding:4px 8px;
      line-height:1; transition:all 0.2s ease;
    }
    .profile-close-btn:hover{color:var(--fg); transform:scale(1.1);}
    .profile-header{
      text-align:center; margin-bottom:20px;
    }
    .profile-avatar{
      width:80px; height:80px; border-radius:50%; background:linear-gradient(135deg, #667eea, #764ba2);
      display:flex; align-items:center; justify-content:center;
      font-size:32px; margin:0 auto 12px; box-shadow:0 8px 20px rgba(0,0,0,.3);
    }
    .profile-name{font-size:24px; font-weight:800; margin-bottom:4px;}
    .profile-stats{
      display:grid; grid-template-columns:repeat(auto-fit, minmax(120px, 1fr)); gap:12px; margin:20px 0;
    }
    .stat-card{
      background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08);
      border-radius:12px; padding:16px; text-align:center;
    }
    .stat-number{font-size:28px; font-weight:800; color:var(--accent);}
    .stat-label{font-size:12px; color:var(--muted); margin-top:4px;}
    .badge-grid{
      display:grid; grid-template-columns:repeat(auto-fit, minmax(140px, 1fr)); gap:12px; margin-top:16px;
    }
    .badge-card{
      background:rgba(255,255,255,0.04); border:1px solid rgba(255,255,255,0.08);
      border-radius:12px; padding:16px; text-align:center; position:relative;
    }
    .badge-card.earned{
      border-color:rgba(46,255,170,0.3); background:rgba(46,255,170,0.05);
    }
    .badge-card.earned .badge-emoji{
      filter:drop-shadow(0 4px 12px rgba(46,255,170,.3));
    }
    .badge-emoji{font-size:32px; margin-bottom:8px;}
    .badge-title{font-weight:700; font-size:14px; margin-bottom:4px;}
    .badge-subtitle{font-size:12px; color:var(--muted);}
    .badge-locked{
      opacity:0.4; filter:grayscale(0.8);
    }
    .clickable{cursor:pointer; transition:all 0.2s ease;}
    .clickable:hover{transform:translateY(-2px); opacity:0.8;}
    
    /* Tricky Words Grid */
    .tricky-words-grid{
      display:grid; grid-template-columns:repeat(auto-fit, minmax(100px, 1fr)); gap:8px; margin-top:8px;
    }
    .tricky-word-card{
      background:rgba(239,68,68,0.1); border:1px solid rgba(239,68,68,0.3);
      border-radius:8px; padding:8px; text-align:center; font-size:12px; font-weight:700;
      color:#fca5a5;
    }
    
    /* Mastered Words List */
    .mastered-words-list{
      display:grid; grid-template-columns:repeat(auto-fit, minmax(80px, 1fr)); gap:6px; margin-top:8px;
      max-height:200px; overflow-y:auto; padding:8px; background:rgba(255,255,255,0.02);
      border-radius:8px; border:1px solid rgba(255,255,255,0.08);
    }
    .mastered-word-item{
      background:rgba(34,197,94,0.1); border:1px solid rgba(34,197,94,0.3);
      border-radius:6px; padding:6px; text-align:center; font-size:11px; font-weight:600;
      color:#86efac;
    }
    
    /* Streak Counter Styles */
    .streak-counter{
      display:none; /* Hidden by default, shown only in general review mode */
      flex-direction:column; align-items:center; gap:8px;
      margin-top:8px;
    }
    .streak-counter.show{display:flex;}
    .streak-label{
      font-size:14px; font-weight:700; color:var(--muted);
      text-align:center;
    }
    .streak-bar{
      display:flex; gap:2px; align-items:center;
      background:rgba(255,255,255,0.05); border-radius:12px;
      padding:4px; border:1px solid rgba(255,255,255,0.1);
    }
    .streak-segment{
      width:12px; height:8px; border-radius:4px;
      background:rgba(255,255,255,0.1);
      transition:all 0.3s ease;
    }
    .streak-segment.filled{
      background:linear-gradient(90deg, #22c55e, #16a34a);
    }
    .streak-segment.glowing{
      background:linear-gradient(90deg, #fbbf24, #f59e0b);
      box-shadow:0 0 8px rgba(251,191,36,0.6);
      animation:streakGlow 1.5s ease-in-out infinite alternate;
    }
    .streak-segment.rainbow{
      box-shadow:0 0 8px rgba(255,255,255,0.4);
    }
    /* Define 8 color states that will cycle */
    .streak-segment.rainbow-0{background:#ef4444; animation:rainbowChase0 2.4s linear infinite;}
    .streak-segment.rainbow-1{background:#f97316; animation:rainbowChase1 2.4s linear infinite;}
    .streak-segment.rainbow-2{background:#eab308; animation:rainbowChase2 2.4s linear infinite;}
    .streak-segment.rainbow-3{background:#22c55e; animation:rainbowChase3 2.4s linear infinite;}
    .streak-segment.rainbow-4{background:#3b82f6; animation:rainbowChase4 2.4s linear infinite;}
    .streak-segment.rainbow-5{background:#a855f7; animation:rainbowChase5 2.4s linear infinite;}
    .streak-segment.rainbow-6{background:#ec4899; animation:rainbowChase6 2.4s linear infinite;}
    .streak-segment.rainbow-7{background:#38bdf8; animation:rainbowChase7 2.4s linear infinite;}
    
    @keyframes streakGlow{
      0%{box-shadow:0 0 8px rgba(251,191,36,0.6);}
      100%{box-shadow:0 0 16px rgba(251,191,36,0.9), 0 0 24px rgba(251,191,36,0.4);}
    }
    @keyframes rainbowFlow{
      0%{background-position:0% 50%;}
      100%{background-position:200% 50%;}
    }
    /* Rainbow chase animations - each segment cycles through all 8 colors */
    @keyframes rainbowChase0{
      0%{background:#ef4444;} 12.5%{background:#f97316;} 25%{background:#eab308;} 37.5%{background:#22c55e;}
      50%{background:#3b82f6;} 62.5%{background:#a855f7;} 75%{background:#ec4899;} 87.5%{background:#38bdf8;} 100%{background:#ef4444;}
    }
    @keyframes rainbowChase1{
      0%{background:#f97316;} 12.5%{background:#eab308;} 25%{background:#22c55e;} 37.5%{background:#3b82f6;}
      50%{background:#a855f7;} 62.5%{background:#ec4899;} 75%{background:#38bdf8;} 87.5%{background:#ef4444;} 100%{background:#f97316;}
    }
    @keyframes rainbowChase2{
      0%{background:#eab308;} 12.5%{background:#22c55e;} 25%{background:#3b82f6;} 37.5%{background:#a855f7;}
      50%{background:#ec4899;} 62.5%{background:#38bdf8;} 75%{background:#ef4444;} 87.5%{background:#f97316;} 100%{background:#eab308;}
    }
    @keyframes rainbowChase3{
      0%{background:#22c55e;} 12.5%{background:#3b82f6;} 25%{background:#a855f7;} 37.5%{background:#ec4899;}
      50%{background:#38bdf8;} 62.5%{background:#ef4444;} 75%{background:#f97316;} 87.5%{background:#eab308;} 100%{background:#22c55e;}
    }
    @keyframes rainbowChase4{
      0%{background:#3b82f6;} 12.5%{background:#a855f7;} 25%{background:#ec4899;} 37.5%{background:#38bdf8;}
      50%{background:#ef4444;} 62.5%{background:#f97316;} 75%{background:#eab308;} 87.5%{background:#22c55e;} 100%{background:#3b82f6;}
    }
    @keyframes rainbowChase5{
      0%{background:#a855f7;} 12.5%{background:#ec4899;} 25%{background:#38bdf8;} 37.5%{background:#ef4444;}
      50%{background:#f97316;} 62.5%{background:#eab308;} 75%{background:#22c55e;} 87.5%{background:#3b82f6;} 100%{background:#a855f7;}
    }
    @keyframes rainbowChase6{
      0%{background:#ec4899;} 12.5%{background:#38bdf8;} 25%{background:#ef4444;} 37.5%{background:#f97316;}
      50%{background:#eab308;} 62.5%{background:#22c55e;} 75%{background:#3b82f6;} 87.5%{background:#a855f7;} 100%{background:#ec4899;}
    }
    @keyframes rainbowChase7{
      0%{background:#38bdf8;} 12.5%{background:#ef4444;} 25%{background:#f97316;} 37.5%{background:#eab308;}
      50%{background:#22c55e;} 62.5%{background:#3b82f6;} 75%{background:#a855f7;} 87.5%{background:#ec4899;} 100%{background:#38bdf8;}
    }
  </style>
</head>
<body>
  <div class="app" id="app">
    <header>
      <div class="header-top">
        <div class="header-info">
          <button id="profileBtn" class="profile-button clickable" title="View your progress and badges">
            <div class="profile-button-content">
              <div class="student-name" id="studentNameLabel">Student</div>
              <div class="badge-row-inline" id="badgeRow"></div>
            </div>
          </button>
          <button id="changeLevelBtn" class="level-button clickable" title="Click to change level">
            <div class="level-button-top">
              <span class="dot" id="levelDot" style="background:#ef4444"></span>
              <span id="levelText">Red Level Study Mode</span>
            </div>
            <div class="level-button-bottom">Click to Change Level</div>
          </button>
        </div>
      </div>
    </header>

    <main class="word-area">
      <div class="word" id="wordDisplay">Loading‚Ä¶</div>

      <div class="tapzones">
        <div class="zone zone-left" id="zoneWrong" aria-label="Missed it (Left)">
          <div class="zone-label">Missed it</div>
        </div>
        <div class="zone zone-right" id="zoneRight" aria-label="Got it right (Right)">
          <div class="zone-label">Got it!</div>
        </div>
      </div>

      <div class="tip" style="display:none;">Tap left/right ‚Ä¢ Keys: <b>W</b>=wrong, <b>R</b>=right</div>
    </main>

    <footer>
      <div class="progress">
        <div class="bar-wrap">
          <div class="bar-label" id="progressLabel">Mastery</div>
          <div class="bar" id="progressBar" title="Progress"><span id="progressFill"></span></div>
        </div>
      </div>
      
      <!-- Streak Counter (shown only in general review mode) -->
      <div class="streak-counter" id="streakCounter">
        <div class="streak-label" id="streakLabel">Streak: 10</div>
        <div class="streak-bar" id="streakBar">
          <!-- 20 segments will be generated by JavaScript -->
        </div>
      </div>
      
      <div class="stats">
        <div id="statLearned">Learned: 0/12</div>
        <button id="resetLevelBtn" class="reset-level-footer" title="Reset this level's progress">Reset Current Level</button>
      </div>
    </footer>
  </div>

  <!-- Welcome / Student name and app overview -->
  <div class="overlay" id="welcomeOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h2>Welcome to Rainbow Words Trainer! üåà</h2>
      <div class="muted">Who's practicing today?</div>
      <div style="margin-top:8px">
        <input id="studentNameInput" type="text" placeholder="Type student name‚Ä¶" />
      </div>
      
      <div style="margin-top:20px">
        <h3 style="margin:0 0 12px 0; font-size:16px;">How it works:</h3>
        <div style="display:flex; gap:12px; flex-direction:column;">
          <div style="display:flex; align-items:flex-start; gap:12px;">
            <div style="width:20px; height:20px; border-radius:50%; background:#ffffff; flex-shrink:0; margin-top:2px;">üåà</div>
            <div>
              <div style="font-weight:700; font-size:14px;">Level Mode</div>
              <div style="font-size:12px; color:var(--muted);">Work through 8 rainbow levels (Red ‚Üí Light Blue). While you practice, you'll also see words from completed levels‚Äîespecially tricky ones‚Äîto keep them fresh!</div>
            </div>
          </div>
          <div style="display:flex; align-items:flex-start; gap:12px;">
            <div style="width:20px; height:20px; border-radius:50%; background:#fbbf24; display:flex; align-items:center; justify-content:center; font-size:12px; flex-shrink:0; margin-top:2px;">üìö</div>
            <div>
              <div style="font-weight:700; font-size:14px;">Review Mode</div>
              <div style="font-size:12px; color:var(--muted);">Practice all mastered words from any level. Build streaks and stay sharp!</div>
            </div>
          </div>
        </div>
      </div>
      
      <div style="margin-top:16px; padding:12px; background:rgba(110,168,254,0.08); border-radius:8px; border:1px solid rgba(110,168,254,0.2);">
        <div style="font-size:12px; color:var(--accent); font-weight:700; margin-bottom:4px;">üí° Quick Tips:</div>
        <div style="font-size:11px; color:var(--muted); line-height:1.4;">
          ‚Ä¢ Tap the red zone if a word is missed, right if they got it<br>
          ‚Ä¢ Use the W and R keys if working on a computer (Wrong = W, Right = R)<br>
          ‚Ä¢ Tap the student's name to see progress, badges, and stats. Also export and import progress in the profile to transfer between devices or keep a backup<br>
          ‚Ä¢ Everything is saved locally in your browser<br>
        </div>
      </div>
      
      <div class="btn-row">
        <button id="saveStudentBtn">Let's Start!</button>
        <button id="importFromWelcomeBtn" class="ghost">üì• Import Profile</button>
      </div>
    </div>
  </div>

  <!-- Level picker (shown AFTER name is saved) -->
  <div class="overlay" id="levelOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <h2>What level are you on?</h2>
      <div class="muted">Pick your color. You can change this anytime.</div>
      <div class="level-grid" id="levelGrid"></div>
      <div class="btn-row">
        <button id="closeLevelBtn" class="ghost">Close</button>
      </div>
    </div>
  </div>

  <!-- "Ready for review?" modal -->
  <div class="overlay" id="preFinalOverlay" role="dialog" aria-modal="true">
    <div class="card">
      <div class="fun-wrap">
        <div class="fun-emoji">üß†</div>
        <div>
          <h2>Looks like you've got these words!</h2>
          <div class="muted">Let's do a quick review to make sure you really know them, then you can earn your <b id="badgeName">Red</b> badge!</div>
        </div>
      </div>
      <div class="row" style="margin-top:8px">
        <div class="muted">Get in a little more practice, or try the test again!</div>
      </div>
      <div class="btn-row">
        <button id="startReviewBtn">Start Review</button>
      </div>
    </div>
  </div>

  <!-- Test results / review -->
  <div class="overlay" id="testResultOverlay" role="dialog" aria-modal="true">
    <div class="card" id="testResultCard">
      <h2 id="testResultTitle">Test Finished</h2>
      <div class="muted" id="testResultSub">Score: 0%</div>
      <div id="missedList" class="muted" style="margin-top:8px"></div>
      <div class="btn-row" id="testButtons">
        <button id="startQuickReviewBtn">Quick Review</button>
        <button id="retestBtn" class="ghost" disabled>Test</button>
      </div>
    </div>
  </div>

  <!-- Badge Celebration Animation -->
  <div class="badge-celebration" id="badgeCelebration">
    <div class="confetti-container" id="confettiContainer"></div>
    <div class="badge-burst">
      <span class="emoji-badge" id="celebrationBadge">üèÖ</span>
    </div>
  </div>

  <!-- Profile Modal -->
  <div class="profile-overlay" id="profileOverlay" role="dialog" aria-modal="true">
    <div class="profile-card">
      <button id="closeProfileBtn" class="profile-close-btn" title="Close">√ó</button>
      <div class="profile-header">
        <div class="profile-avatar">üë§</div>
        <div class="profile-name" id="profileName">Student</div>
        <div class="muted">Sight Words Champion</div>
      </div>
      
      <div class="profile-stats">
        <div class="stat-card">
          <div class="stat-number" id="totalWordsMastered">0</div>
          <div class="stat-label">Words Mastered</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalTrickyWords">0</div>
          <div class="stat-label">Tricky Words</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="totalWordsSeen">0</div>
          <div class="stat-label">Words Seen</div>
        </div>
        <div class="stat-card">
          <div class="stat-number" id="completionRate">0%</div>
          <div class="stat-label">Completion</div>
        </div>
      </div>

      <h3 style="margin:20px 0 12px 0; font-size:18px;">Badge Collection</h3>
      <div class="badge-grid" id="profileBadgeGrid"></div>
      
      <h3 style="margin:20px 0 12px 0; font-size:18px;">Tricky Word Collection</h3>
      <div class="tricky-words-grid" id="trickyWordsGrid"></div>
      
      <h3 style="margin:20px 0 12px 0; font-size:18px;">Mastered Words</h3>
      <div class="mastered-words-list" id="masteredWordsList"></div>
      
      <div style="margin-top:20px; padding-top:20px; border-top:1px solid rgba(255,255,255,0.1);">
        <h3 style="margin:0 0 12px 0; font-size:16px; text-align:center;">Backup & Restore</h3>
        <div class="muted" style="font-size:12px; text-align:center; margin-bottom:12px;">Save progress to transfer between devices or keep a backup</div>
        <div style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
          <button id="exportProgressBtn" style="background:transparent; color:var(--accent); border:1px solid var(--accent); font-size:14px; padding:10px 20px; border-radius:10px; font-weight:700; cursor:pointer;" title="Export profile data">üì§ Export Profile</button>
          <button id="importProgressBtn" style="background:transparent; color:var(--accent); border:1px solid var(--accent); font-size:14px; padding:10px 20px; border-radius:10px; font-weight:700; cursor:pointer;" title="Import profile data">üì• Import Profile</button>
        </div>
      </div>
      
      <div style="margin-top:20px; padding-top:20px; border-top:1px solid rgba(255,255,255,0.1); text-align:center;">
        <button id="resetAllBtn" style="background:transparent; color:#ef4444; border:1px solid #ef4444; font-size:12px; padding:8px 16px;" title="Reset ALL progress">Reset All Progress</button>
      </div>
    </div>
  </div>

  <!-- Success overlay -->
  <div class="success" id="success">
    <div class="success-card">
      <svg class="trophy" viewBox="0 0 256 256" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <defs><linearGradient id="g" x1="0" x2="1" y1="0" y2="1"><stop offset="0%" stop-color="#5ff3b1"/><stop offset="100%" stop-color="#2d6fea"/></linearGradient></defs>
        <path fill="url(#g)" d="M216 40h-32V24a8 8 0 0 0-8-8H80a8 8 0 0 0-8 8v16H40a8 8 0 0 0-8 8v24c0 28.6 20.7 52.5 48 58.3A72.2 72.2 0 0 0 120 176v16H88a8 8 0 1 0 0 16h80a8 8 0 1 0 0-16h-32v-16a72.2 72.2 0 0 0 40-45.7c27.3-5.8 48-29.7 48-58.3V48a8 8 0 0 0-8-8Zm-168 32V56h24v37.9C59.1 90.5 48 77.1 48 72Zm160 0c0 5.1-11.1 18.5-24 21.9V56h24v16Z"/>
      </svg>
      <h2 id="successTitle">Level Mastered!</h2>
      <p id="successText">You got 100% on the test. Badge earned! üéâ</p>
      <div class="row center" style="gap:12px; margin-bottom:10px">
        <span class="emoji-badge" id="earnedBadge">üèÖ</span>
        <span class="pill">Badge added to your belt</span>
      </div>
      <div class="btn-row">
        <button id="reviewAgainBtn">Next Level</button>
        <button class="ghost" id="pickNextLevelBtn">Choose a Level</button>
      </div>
    </div>
  </div>

  <script>
  (function(){
    const STORAGE_KEY = 'sightwords_rainbow_v3';

    // ==== YOUR RAINBOW LEVELS ====
    // LEVELS will be loaded from words.json
    let LEVELS = [];
    // ==============================

    // Mastery & tricky rules (per your notes)
    const TRICKY_ADD_AFTER_WRONGS = 2;      // 2 total misses ‚Üí tricky
    const TRICKY_REMOVE_AFTER_STREAK = 5;   // 5 in a row ‚Üí remove tricky

    // Weighting and spacing
    const WRONG_FACTOR = 4;
    const MIN_WEIGHT = 1;
    const HISTORY_BLOCK = 3;                // avoid showing any of last N words
    // Removed fixed percentages - now using unified weighted pool system

    // Quick review rules after a test fail
    const REVIEW_MISSED_MULTIPLIER = 3; // each missed word appears 3√ó in review
    
    // Learning science improvements
    const REVIEW_THRESHOLD_DAYS = 2;    // words not seen in 2+ days get priority
    const RETRY_DELAY = 3;              // show 3 other words before retry
    const MASTERY_STREAK_REQUIRED = 2;  // require 2 correct in a row
    const MASTERY_SESSIONS_REQUIRED = 1; // require 1 session (more reasonable for single study session)
    const MASTERY_TIME_SPAN_DAYS = 0;   // require 0 days (allow same-day mastery)
    const MASTERED_STREAK = MASTERY_STREAK_REQUIRED; // Now uses enhanced mastery requirements

    // State model
    // perLevel.words: { text, seen, correct, wrong, streak, mastered:boolean, tricky:boolean, lastSeenTimestamp:Date, masteryDates:Date[], sessionsSeen:number }
    let state = loadState() || makeFreshState();

    // Runtime
    let levelIdx = state.levelIdx ?? 0;
    let currentIndex = -1;
    let phase = state.phase || 'study'; // 'study' | 'prefinal' | 'review' | 'final' | 'postreview'
    let finalQueue = state.finalQueue || [];
    let finalPosition = state.finalPosition || 0;
    let seenTotal = state.seenTotal || 0;

    let firstPassQueue = state.firstPassQueue || []; // all words once before repeats
    let history = state.history || [];               // recent indices to avoid repeats

    let testResults = state.testResults || [];       // {idx, correct}
    let missedFromTest = state.missedFromTest || [];
    let reviewQueue = state.reviewQueue || [];
    let missedFromReview = [];
    
    // Review session variables
    let reviewSessionQueue = state.reviewSessionQueue || [];
    let reviewSessionPosition = state.reviewSessionPosition || 0;
    let reviewSessionResults = state.reviewSessionResults || [];

    let studentName = state.studentName || '';
    let cooldownNextKnown = state.cooldownNextKnown || 0; // after a miss, force next to known
    let reviewMode = state.reviewMode || 'current'; // 'current' or 'general'
    let isAfterSuccessfulReview = false; // Track if we're showing options after a successful review
    let reviewStreak = state.reviewStreak || 10; // Current streak counter (starts at middle: 10/20)
    
    // Learning science additions
    function generateSessionId() {
      return Date.now().toString(36) + Math.random().toString(36).substr(2);
    }
    
    let currentSessionId = state.currentSessionId || generateSessionId();
    let retryQueue = state.retryQueue || []; // [{wordIdx, attemptsLeft}]
    
    // Cross-level review system (now integrated into unified pool)

    const els = {
      word: document.getElementById('wordDisplay'),
      zoneRight: document.getElementById('zoneRight'),
      zoneWrong: document.getElementById('zoneWrong'),
      barMastery: document.getElementById('progressFill'),
      barFinal: document.getElementById('progressFill'),
      statLearned: document.getElementById('statLearned'),
      success: document.getElementById('success'),
      reviewAgainBtn: document.getElementById('reviewAgainBtn'),
      pickNextLevelBtn: document.getElementById('pickNextLevelBtn'),
      changeLevelBtn: document.getElementById('changeLevelBtn'),
      resetLevelBtn: document.getElementById('resetLevelBtn'),
      resetAllBtn: document.getElementById('resetAllBtn'),
      levelOverlay: document.getElementById('levelOverlay'),
      levelGrid: document.getElementById('levelGrid'),
      closeLevelBtn: document.getElementById('closeLevelBtn'),
      levelDot: document.getElementById('levelDot'),
      levelName: document.getElementById('levelName'),
      badgeRow: document.getElementById('badgeRow'),
      badgeName: document.getElementById('badgeName'),
      successTitle: document.getElementById('successTitle'),
      successText: document.getElementById('successText'),
      earnedBadge: document.getElementById('earnedBadge'),
      preFinalOverlay: document.getElementById('preFinalOverlay'),
      testResultOverlay: document.getElementById('testResultOverlay'),
      testResultTitle: document.getElementById('testResultTitle'),
      testResultSub: document.getElementById('testResultSub'),
      missedList: document.getElementById('missedList'),
      startQuickReviewBtn: document.getElementById('startQuickReviewBtn'),
      retestBtn: document.getElementById('retestBtn'),
      welcomeOverlay: document.getElementById('welcomeOverlay'),
      studentNameInput: document.getElementById('studentNameInput'),
      saveStudentBtn: document.getElementById('saveStudentBtn'),
      studentNameLabel: document.getElementById('studentNameLabel'),
      // New elements
      badgeCelebration: document.getElementById('badgeCelebration'),
      celebrationBadge: document.getElementById('celebrationBadge'),
      confettiContainer: document.getElementById('confettiContainer'),
      profileOverlay: document.getElementById('profileOverlay'),
      profileName: document.getElementById('profileName'),
      totalWordsMastered: document.getElementById('totalWordsMastered'),
      totalTrickyWords: document.getElementById('totalTrickyWords'),
      totalWordsSeen: document.getElementById('totalWordsSeen'),
      completionRate: document.getElementById('completionRate'),
      profileBadgeGrid: document.getElementById('profileBadgeGrid'),
      trickyWordsGrid: document.getElementById('trickyWordsGrid'),
      masteredWordsList: document.getElementById('masteredWordsList'),
      closeProfileBtn: document.getElementById('closeProfileBtn'),
      exportProgressBtn: document.getElementById('exportProgressBtn'),
      importProgressBtn: document.getElementById('importProgressBtn'),
      streakCounter: document.getElementById('streakCounter'),
      streakLabel: document.getElementById('streakLabel'),
      streakBar: document.getElementById('streakBar'),
      progressLabel: document.getElementById('progressLabel'),
      progressBar: document.getElementById('progressBar'),
      progressFill: document.getElementById('progressFill'),
    };

    // ======= STATE HELPERS =======
    function makeFreshState(){
      return {
        perLevel: LEVELS.map(lvl => ({
          words: (lvl.words || []).map(w => ({
            text: w, seen:0, correct:0, wrong:0, streak:0, mastered:false, tricky:false,
            lastSeenTimestamp: null, masteryDates: [], sessionsSeen: 0, currentSessionSeen: false
          })),
          badgeEarned: false
        })),
        levelIdx: 0,
        phase: 'study',
        finalQueue: [],
        finalPosition: 0,
        seenTotal: 0,
        firstPassQueue: [],
        history: [],
        testResults: [],
        missedFromTest: [],
        reviewQueue: [],
        studentName: '',
        cooldownNextKnown: 0,
        currentSessionId: generateSessionId(),
        retryQueue: [],
        reviewMode: 'current',
        reviewSessionQueue: [],
        reviewSessionPosition: 0,
        reviewSessionResults: [],
      };
    }

    function saveState(){
      state.levelIdx = levelIdx;
      state.phase = phase;
      state.finalQueue = finalQueue;
      state.finalPosition = finalPosition;
      state.seenTotal = seenTotal;
      state.firstPassQueue = firstPassQueue;
      state.history = history;
      state.testResults = testResults;
      state.missedFromTest = missedFromTest;
      state.reviewQueue = reviewQueue;
      state.reviewSessionQueue = reviewSessionQueue;
      state.reviewSessionPosition = reviewSessionPosition;
      state.reviewSessionResults = reviewSessionResults;
      state.studentName = studentName;
      state.cooldownNextKnown = cooldownNextKnown;
      state.currentSessionId = currentSessionId;
      state.retryQueue = retryQueue;
      state.reviewMode = reviewMode;
      state.reviewStreak = reviewStreak;
      try { localStorage.setItem(STORAGE_KEY, JSON.stringify(state)); } catch(e){}
    }

    function loadState(){
      try{
        const s = localStorage.getItem(STORAGE_KEY);
        if(!s) return null;
        const parsed = JSON.parse(s);
        if(!parsed.perLevel || !Array.isArray(parsed.perLevel)) return null;
        // If LEVELS length changed, migrate conservatively
        if (parsed.perLevel.length !== LEVELS.length){
          const fresh = makeFreshState();
          const n = Math.min(parsed.perLevel.length, fresh.perLevel.length);
          for(let i=0;i<n;i++){ fresh.perLevel[i] = parsed.perLevel[i]; }
          fresh.levelIdx = Math.min(parsed.levelIdx || 0, LEVELS.length-1);
          fresh.phase = parsed.phase || 'study';
          fresh.finalQueue = parsed.finalQueue || [];
          fresh.finalPosition = parsed.finalPosition || 0;
          fresh.seenTotal = parsed.seenTotal || 0;
          fresh.firstPassQueue = parsed.firstPassQueue || [];
          fresh.history = parsed.history || [];
          fresh.testResults = parsed.testResults || [];
          fresh.missedFromTest = parsed.missedFromTest || [];
          fresh.reviewQueue = parsed.reviewQueue || [];
          fresh.studentName = parsed.studentName || '';
          fresh.cooldownNextKnown = parsed.cooldownNextKnown || 0;
          fresh.currentSessionId = parsed.currentSessionId || generateSessionId();
          fresh.retryQueue = parsed.retryQueue || [];
          fresh.reviewMode = parsed.reviewMode || 'current';
          fresh.reviewSessionQueue = parsed.reviewSessionQueue || [];
          fresh.reviewSessionPosition = parsed.reviewSessionPosition || 0;
          fresh.reviewSessionResults = parsed.reviewSessionResults || [];
          fresh.reviewStreak = parsed.reviewStreak || 10;
          return fresh;
        }
        return parsed;
      }catch(e){ return null; }
    }

    function currentLevel(){ return state.perLevel[levelIdx]; }
    function words(){ return currentLevel().words; }
    function allMasteredInLevel(){
      const w = words();
      if (!w.length) return false;
      // Only allow test if ALL words are mastered
      const masteredCount = w.filter(x => x.mastered).length;
      return masteredCount === w.length;
    }
    function masteredCount(){ return words().filter(w=>w.mastered).length; }

    // ======= LEARNING SCIENCE UTILITIES =======
    function getDaysSince(timestamp) {
      if (!timestamp) return 999; // Never seen = high priority
      const now = new Date();
      const diffTime = Math.abs(now - new Date(timestamp));
      return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    }
    
    function getDaysBetween(date1, date2) {
      const diffTime = Math.abs(new Date(date2) - new Date(date1));
      return Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    }
    
    function checkMastery(word) {
      // Handle backward compatibility for new fields
      const streak = word.streak || 0;
      const sessionsSeen = word.sessionsSeen || 0;
      const masteryDates = word.masteryDates || [];
      
      // Require minimum streak
      if (streak < MASTERY_STREAK_REQUIRED) return false;
      
      // Require multiple sessions
      if (sessionsSeen < MASTERY_SESSIONS_REQUIRED) return false;
      
      // Require time span between first and last correct
      if (masteryDates.length < MASTERY_STREAK_REQUIRED) return false;
      const daySpan = getDaysBetween(
        masteryDates[0], 
        masteryDates[masteryDates.length - 1]
      );
      if (daySpan < MASTERY_TIME_SPAN_DAYS) return false;
      
      word.mastered = true;
      return true;
    }
    
    function onWordShown(wordIdx) {
      const word = words()[wordIdx];
      
      // Safety check for invalid word index
      if (!word) {
        console.error('onWordShown called with invalid word index:', wordIdx);
        return;
      }
      
      // Initialize new fields if they don't exist (for backward compatibility)
      if (!word.hasOwnProperty('lastSeenTimestamp')) word.lastSeenTimestamp = null;
      if (!word.hasOwnProperty('masteryDates')) word.masteryDates = [];
      if (!word.hasOwnProperty('sessionsSeen')) word.sessionsSeen = 0;
      if (!word.hasOwnProperty('currentSessionSeen')) word.currentSessionSeen = false;
      
      word.lastSeenTimestamp = new Date();
      
      // Track sessions
      if (!word.currentSessionSeen) {
        word.sessionsSeen = (word.sessionsSeen || 0) + 1;
        word.currentSessionSeen = true;
      }
    }
    
    function endSession() {
      words().forEach(w => w.currentSessionSeen = false);
    }
    
    // Cross-level review functions (now integrated into unified pool system)
    
    function getAllWordsForSelection() {
      const allWords = [];
      
      if (reviewMode === 'general') {
        // GENERAL REVIEW MODE: Only include mastered words from all levels
        for (let levelIndex = 0; levelIndex < state.perLevel.length; levelIndex++) {
          const levelWords = state.perLevel[levelIndex].words;
          levelWords.forEach((word, wordIdx) => {
            // Only include mastered words in general review mode
            if (word.mastered) {
              allWords.push({
                word: word,
                levelIdx: levelIndex,
                wordIdx: wordIdx,
                isFromPreviousLevel: levelIndex !== levelIdx // Cross-level if not from current level
              });
            }
          });
        }
      } else {
        // CURRENT LEVEL FOCUS MODE: Include current level words + some previous level words
        // Add current level words
        words().forEach((word, idx) => {
          allWords.push({
            word: word,
            levelIdx: levelIdx,
            wordIdx: idx,
            isFromPreviousLevel: false
          });
        });
        
        // Add previous level words (only for levels after Red)
        if (levelIdx > 0) {
          for (let prevLevel = 0; prevLevel < levelIdx; prevLevel++) {
            const prevWords = state.perLevel[prevLevel].words;
            prevWords.forEach((word, wordIdx) => {
              // Always include tricky and mastered words for better retention
              // This ensures same-day practice includes previous level words
              if (word.tricky || word.mastered) {
                allWords.push({
                  word: word,
                  levelIdx: prevLevel,
                  wordIdx: wordIdx,
                  isFromPreviousLevel: true
                });
              }
            });
          }
        }
      }
      
      return allWords;
    }
    
    function getCriticalWords() {
      const criticalWords = [];
      
      if (reviewMode === 'general') {
        // GENERAL REVIEW MODE: Check all levels for critical words
        for (let levelIndex = 0; levelIndex < state.perLevel.length; levelIndex++) {
          const levelWords = state.perLevel[levelIndex].words;
          levelWords.forEach((word, wordIdx) => {
            const daysSince = getDaysSince(word.lastSeenTimestamp);
            if (daysSince >= 7 && word.mastered) {
              criticalWords.push({
                word: word,
                levelIdx: levelIndex,
                wordIdx: wordIdx,
                isFromPreviousLevel: levelIndex !== levelIdx // Cross-level if not from current level
              });
            }
          });
        }
      } else {
        // CURRENT LEVEL FOCUS MODE: Check current level and previous levels
        // Check current level
        words().forEach((word, idx) => {
          const daysSince = getDaysSince(word.lastSeenTimestamp);
          if (daysSince >= 7 && !word.mastered) {
            criticalWords.push({
              word: word,
              levelIdx: levelIdx,
              wordIdx: idx,
              isFromPreviousLevel: false
            });
          }
        });
        
        // Check previous levels (only for levels after Red)
        if (levelIdx > 0) {
          for (let prevLevel = 0; prevLevel < levelIdx; prevLevel++) {
            const prevWords = state.perLevel[prevLevel].words;
            prevWords.forEach((word, wordIdx) => {
              const daysSince = getDaysSince(word.lastSeenTimestamp);
              // Critical if not seen in 5+ days for better retention (includes mastered words)
              if (daysSince >= 5) {
                criticalWords.push({
                  word: word,
                  levelIdx: prevLevel,
                  wordIdx: wordIdx,
                  isFromPreviousLevel: true
                });
              }
            });
          }
        }
      }
      
      return criticalWords;
    }
    
    function pickFromUnifiedPool() {
      // Get all words first to check for tricky words
      const allWords = getAllWordsForSelection();
      const hasTricky = hasTrickyWordsInPool(allWords);
      
      // TIER 1: Critical reviews (always prioritize words not seen in 5+ days)
      const criticalWords = getCriticalWords();
      if (criticalWords.length > 0) {
        // Filter out words in history
        let pool = criticalWords.filter(w => !history.includes(w.wordIdx));
        if (pool.length === 0) pool = criticalWords;
        
        // Calculate weights for critical words
        let totalWeight = 0;
        const weights = pool.map(w => {
          const levelDistance = w.isFromPreviousLevel ? (levelIdx - w.levelIdx) : 0;
          const weight = computeWeight(w.word, w.isFromPreviousLevel, levelDistance, hasTricky);
          totalWeight += weight;
          return weight;
        });
        
        // Pick weighted random from critical words
        let random = Math.random() * totalWeight;
        for (let i = 0; i < pool.length; i++) {
          random -= weights[i];
          if (random <= 0) {
            return pool[i];
          }
        }
        return pool[pool.length - 1];
      }
      
      // TIER 2: Regular weighted selection from all available words
      // allWords already declared at the top of function
      if (allWords.length === 0) return null;
      
      // Filter out words in history (unless pool is too small)
      let pool = allWords.filter(w => !history.includes(w.wordIdx) || allWords.length <= HISTORY_BLOCK);
      if (pool.length === 0) pool = allWords;
      
      // Calculate weights
      let totalWeight = 0;
      const weights = pool.map(w => {
        const levelDistance = w.isFromPreviousLevel ? (levelIdx - w.levelIdx) : 0;
        const weight = computeWeight(w.word, w.isFromPreviousLevel, levelDistance, hasTricky);
        totalWeight += weight;
        return weight;
      });
      
      // Pick weighted random
      let random = Math.random() * totalWeight;
      for (let i = 0; i < pool.length; i++) {
        random -= weights[i];
        if (random <= 0) {
          return pool[i];
        }
      }
      
      // Fallback
      return pool[pool.length - 1];
    }

    // ======= UI =======
    function updateHeader(){
      const levelTextEl = document.getElementById('levelText');
      
      if (reviewMode === 'general') {
        // All Known Words mode
        els.levelDot.classList.add('rainbow');
        els.levelDot.style.background = '';
        if (levelTextEl) levelTextEl.textContent = 'All Known Words Review';
      } else {
        // Normal level mode
        const lvl = LEVELS[levelIdx];
        els.levelDot.classList.remove('rainbow');
        els.levelDot.style.background = lvl.color;
        if (levelTextEl) levelTextEl.textContent = `${lvl.name} Level Study Mode`;
      }
      
      els.studentNameLabel.textContent = studentName ? `üë§ Profile: ${studentName}` : '';
    }
    
    function showBadgeCelebration(badgeEmoji){
      // Clear any existing confetti
      els.confettiContainer.innerHTML = '';
      
      // Create confetti pieces
      const confettiColors = [
        '#ff6b6b', '#4ecdc4', '#45b7d1', '#f9ca24', '#6c5ce7', 
        '#fd79a8', '#00b894', '#e17055', '#74b9ff', '#fdcb6e', 
        '#e84393', '#00cec9', '#a29bfe', '#ff7675'
      ];
      
      for(let i = 0; i < 480; i++){ // Doubled from 120 to 240 for more celebration!
        const confetti = document.createElement('div');
        confetti.className = 'confetti-piece';
        confetti.style.background = confettiColors[i % confettiColors.length];
        
        // Create variety in starting positions - some from top, some from sides, some from corners
        const startPosition = Math.random();
        let startX, startY;
        
        if (startPosition < 0.4) {
          // 40% from top edge (various horizontal positions)
          startX = Math.random() * 100 + '%';
          startY = '-150px';
        } else if (startPosition < 0.7) {
          // 30% from left side
          startX = '-50px';
          startY = Math.random() * 100 + '%';
        } else if (startPosition < 0.9) {
          // 20% from right side
          startX = 'calc(100% + 50px)';
          startY = Math.random() * 100 + '%';
        } else {
          // 10% from corners (more dramatic)
          const corner = Math.random();
          if (corner < 0.5) {
            startX = '-100px';
            startY = '-100px';
          } else {
            startX = 'calc(100% + 50px)';
            startY = '-100px';
          }
        }
        
        confetti.style.left = startX;
        confetti.style.top = startY;
        confetti.style.animationDelay = Math.random() * 2 + 's';
        confetti.style.animationDuration = (2 + Math.random() * 2) + 's';
        els.confettiContainer.appendChild(confetti);
      }
      
      els.celebrationBadge.textContent = badgeEmoji;
      els.badgeCelebration.classList.add('show');
      
      // Hide the celebration container after confetti has fallen (4-5 seconds)
      // This allows confetti to fall naturally off screen
      setTimeout(() => {
        hideBadgeCelebration();
      }, 5000);
    }
    
    function hideBadgeCelebration(){
      els.badgeCelebration.classList.remove('show');
      // Clear confetti after animation
      setTimeout(() => {
        els.confettiContainer.innerHTML = '';
      }, 100);
    }
    
    function calculateTotalStats(){
      let totalMastered = 0;
      let totalBadges = 0;
      let totalWords = 0;
      let totalTricky = 0;
      
      state.perLevel.forEach(level => {
        totalMastered += level.words.filter(w => w.mastered).length;
        totalWords += level.words.length;
        totalTricky += level.words.filter(w => w.tricky).length;
        if (level.badgeEarned) totalBadges++;
      });
      
      const completion = totalWords > 0 ? Math.round((totalMastered / totalWords) * 100) : 0;
      
      return { totalMastered, totalBadges, totalWords, totalTricky, completion, totalSeen: seenTotal };
    }
    
    function updateProfileStats(){
      const stats = calculateTotalStats();
      els.totalWordsMastered.textContent = stats.totalMastered;
      els.totalTrickyWords.textContent = stats.totalTricky;
      els.totalWordsSeen.textContent = stats.totalSeen;
      els.completionRate.textContent = stats.completion + '%';
    }
    
    function populateProfileBadges(){
      els.profileBadgeGrid.innerHTML = '';
      LEVELS.forEach((lvl, i) => {
        const levelData = state.perLevel[i];
        const isEarned = levelData.badgeEarned;
        const masteredCount = levelData.words.filter(w => w.mastered).length;
        const totalCount = levelData.words.length;
        
        const card = document.createElement('div');
        card.className = `badge-card ${isEarned ? 'earned' : 'badge-locked'}`;
        card.innerHTML = `
          <div class="badge-emoji">${lvl.badge}</div>
          <div class="badge-title">${lvl.name}</div>
          <div class="badge-subtitle">${masteredCount}/${totalCount} words</div>
        `;
        els.profileBadgeGrid.appendChild(card);
      });
    }
    
    function populateTrickyWords(){
      els.trickyWordsGrid.innerHTML = '';
      const allTrickyWords = [];
      
      state.perLevel.forEach(level => {
        level.words.forEach(word => {
          if (word.tricky) {
            allTrickyWords.push(word.text);
          }
        });
      });
      
      if (allTrickyWords.length === 0) {
        els.trickyWordsGrid.innerHTML = '<div style="color:var(--muted); font-size:12px; text-align:center; padding:20px;">No tricky words yet!</div>';
        return;
      }
      
      allTrickyWords.forEach(word => {
        const card = document.createElement('div');
        card.className = 'tricky-word-card';
        card.textContent = word;
        els.trickyWordsGrid.appendChild(card);
      });
    }
    
    function populateMasteredWords(){
      els.masteredWordsList.innerHTML = '';
      const allMasteredWords = [];
      
      state.perLevel.forEach(level => {
        level.words.forEach(word => {
          if (word.mastered) {
            allMasteredWords.push(word.text);
          }
        });
      });
      
      if (allMasteredWords.length === 0) {
        els.masteredWordsList.innerHTML = '<div style="color:var(--muted); font-size:12px; text-align:center; padding:20px;">No words mastered yet!</div>';
        return;
      }
      
      allMasteredWords.forEach(word => {
        const item = document.createElement('div');
        item.className = 'mastered-word-item';
        item.textContent = word;
        els.masteredWordsList.appendChild(item);
      });
    }
    
    function openProfile(){
      els.profileName.textContent = studentName || 'Student';
      updateProfileStats();
      populateProfileBadges();
      populateTrickyWords();
      populateMasteredWords();
      els.profileOverlay.classList.add('show');
    }
    
    function closeProfile(){
      els.profileOverlay.classList.remove('show');
    }
    
    // ======= IMPORT / EXPORT =======
    function exportProgress(){
      const exportData = {
        version: '1.0',
        exportDate: new Date().toISOString(),
        studentName: studentName,
        data: state
      };
      
      const jsonString = JSON.stringify(exportData, null, 2);
      const fileName = `rainbow-words-${studentName || 'progress'}-${new Date().toISOString().split('T')[0]}.json`;
      
      // Try native share API first (mobile-friendly)
      if (navigator.share && navigator.canShare) {
        const blob = new Blob([jsonString], { type: 'application/json' });
        const file = new File([blob], fileName, { type: 'application/json' });
        
        if (navigator.canShare({ files: [file] })) {
          navigator.share({
            title: 'Rainbow Words Progress',
            text: `Progress backup for ${studentName || 'student'}`,
            files: [file]
          }).catch(err => {
            console.log('Share cancelled or failed:', err);
            fallbackExport(jsonString, fileName);
          });
          return;
        }
      }
      
      // Fallback: download file
      fallbackExport(jsonString, fileName);
    }
    
    function fallbackExport(jsonString, fileName){
      // Try clipboard first on mobile
      if (navigator.clipboard && /mobile|android|iphone|ipad/i.test(navigator.userAgent)) {
        navigator.clipboard.writeText(jsonString).then(() => {
          alert('‚úÖ Progress copied to clipboard!\n\nYou can paste it into a note, text message, or email to save it.');
        }).catch(() => {
          // If clipboard fails, download file
          downloadFile(jsonString, fileName);
        });
      } else {
        // Desktop: download file
        downloadFile(jsonString, fileName);
      }
    }
    
    function downloadFile(content, fileName){
      const blob = new Blob([content], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      alert('‚úÖ Progress file downloaded!\n\nKeep this file safe to restore progress later.');
    }
    
    function importProgress(fromWelcome = false){
      const importModal = document.createElement('div');
      importModal.className = 'overlay show';
      importModal.style.zIndex = '40'; // Higher than profile modal (z-index: 35)
      importModal.innerHTML = `
        <div class="card">
          <h2>Import Progress üì•</h2>
          <div class="muted">Restore progress from a backup file</div>
          
          <div style="margin-top:20px;">
            <div style="display:flex; align-items:center; gap:12px; margin-bottom:16px;">
              <button id="importFromFileBtn" style="width:100%; padding:14px; background:var(--accent); color:#0f1115; border:1px solid var(--accent); border-radius:10px; font-weight:700; cursor:pointer; font-size:16px;">
                üìÅ Choose Backup File
              </button>
            </div>
            
            <div id="fileSelectedArea" style="display:none; margin-bottom:16px; padding:12px; background:rgba(34,197,94,0.08); border-radius:8px; border:1px solid rgba(34,197,94,0.2);">
              <div style="font-size:13px; color:#22c55e; font-weight:700; margin-bottom:4px;">‚úì File Selected</div>
              <div id="selectedFileName" style="font-size:12px; color:var(--muted);"></div>
            </div>
            
            <input type="file" id="importFileInput" accept=".json" style="display:none;">
          </div>
          
          <div style="margin-top:16px; padding:12px; background:rgba(251,191,36,0.08); border-radius:8px; border:1px solid rgba(251,191,36,0.2);">
            <div style="font-size:12px; color:#fbbf24; font-weight:700; margin-bottom:4px;">‚ö†Ô∏è Warning:</div>
            <div style="font-size:11px; color:var(--muted); line-height:1.4;">
              This will replace ALL current progress. Make sure you have a backup of current progress before importing!
            </div>
          </div>
          
          <div class="btn-row" style="margin-top:16px;">
            <button id="confirmImportBtn" style="display:none; background:var(--success); color:#0f1115; border:1px solid var(--success);">Confirm</button>
            <button id="cancelImportBtn" class="ghost">Cancel</button>
          </div>
        </div>
      `;
      
      document.body.appendChild(importModal);
      
      // File input handler
      const fileInput = importModal.querySelector('#importFileInput');
      const importFromFileBtn = importModal.querySelector('#importFromFileBtn');
      const fileSelectedArea = importModal.querySelector('#fileSelectedArea');
      const selectedFileName = importModal.querySelector('#selectedFileName');
      const confirmImportBtn = importModal.querySelector('#confirmImportBtn');
      const cancelBtn = importModal.querySelector('#cancelImportBtn');
      
      let selectedFileData = null;
      
      importFromFileBtn.addEventListener('click', () => {
        fileInput.click();
      });
      
      fileInput.addEventListener('change', (e) => {
        const file = e.target.files[0];
        if (file) {
          console.log('File selected:', file.name);
          // Show file selected feedback
          fileSelectedArea.style.display = 'block';
          selectedFileName.textContent = file.name;
          confirmImportBtn.style.display = 'inline-block';
          console.log('Import button shown');
          
          // Read file but don't import yet
          const reader = new FileReader();
          reader.onload = (event) => {
            selectedFileData = event.target.result;
            console.log('File data loaded, length:', selectedFileData.length);
          };
          reader.onerror = (error) => {
            console.error('Error reading file:', error);
          };
          reader.readAsText(file);
        }
      });
      
      confirmImportBtn.addEventListener('click', () => {
        console.log('Import button clicked!');
        console.log('selectedFileData exists:', !!selectedFileData);
        if (selectedFileData) {
          console.log('Processing import...');
          processImportData(selectedFileData, importModal);
        } else {
          console.error('No file data available');
          alert('Please wait for the file to finish loading and try again.');
        }
      });
      
      cancelBtn.addEventListener('click', () => {
        importModal.remove();
        if (fromWelcome) {
          openWelcome();
        }
      });
      
      importModal.addEventListener('click', (e) => {
        if (e.target === importModal) {
          importModal.remove();
          if (fromWelcome) {
            openWelcome();
          }
        }
      });
    }
    
    function processImportData(jsonString, modal){
      try {
        const importData = JSON.parse(jsonString);
        
        // Validate the data structure
        if (!importData.data || !importData.data.perLevel) {
          throw new Error('Invalid progress data format');
        }
        
        // Close the import modal first
        modal.remove();
        
        // Show custom confirmation modal
        const studentNameText = importData.studentName ? ` for ${importData.studentName}` : '';
        const exportDateText = importData.exportDate ? `<br>Exported: ${new Date(importData.exportDate).toLocaleDateString()}` : '';
        
        const confirmModal = document.createElement('div');
        confirmModal.className = 'overlay show';
        confirmModal.style.zIndex = '50';
        confirmModal.innerHTML = `
          <div class="card">
            <h2>Import This Progress?</h2>
            <div class="muted" style="margin-top:12px;">
              <strong>Student:</strong> ${importData.studentName || 'Unknown'}${exportDateText}
            </div>
            <div style="margin-top:16px; padding:12px; background:rgba(251,191,36,0.08); border-radius:8px; border:1px solid rgba(251,191,36,0.2);">
              <div style="font-size:12px; color:#fbbf24; font-weight:700; margin-bottom:4px;">‚ö†Ô∏è Warning:</div>
              <div style="font-size:12px; color:var(--muted);">This will replace ALL current progress!</div>
            </div>
            <div class="btn-row" style="margin-top:16px;">
              <button id="confirmImport2Btn" style="background:var(--success); color:#0f1115; border:1px solid var(--success);">Confirm</button>
              <button id="cancelImport2Btn" class="ghost">Cancel</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(confirmModal);
        
        document.getElementById('confirmImport2Btn').addEventListener('click', () => {
          confirmModal.remove();
          
          // Apply the imported data
          state = importData.data;
          levelIdx = state.levelIdx ?? 0;
          phase = state.phase || 'study';
          finalQueue = state.finalQueue || [];
          finalPosition = state.finalPosition || 0;
          seenTotal = state.seenTotal || 0;
          firstPassQueue = state.firstPassQueue || [];
          history = state.history || [];
          testResults = state.testResults || [];
          missedFromTest = state.missedFromTest || [];
          reviewQueue = state.reviewQueue || [];
          reviewSessionQueue = state.reviewSessionQueue || [];
          reviewSessionPosition = state.reviewSessionPosition || 0;
          reviewSessionResults = state.reviewSessionResults || [];
          studentName = state.studentName || '';
          cooldownNextKnown = state.cooldownNextKnown || 0;
          retryQueue = state.retryQueue || [];
          reviewMode = state.reviewMode || 'current';
          reviewStreak = state.reviewStreak || 10;
          
          saveState();
          
          // Refresh UI
          updateHeader();
          updateBadges();
          updatePhaseBadge();
          updateProgressBars();
          closeProfile();
          
          alert('‚úÖ Progress imported successfully!\n\nWelcome back, ' + (studentName || 'student') + '!');
          
          // Show the word
          nextWord();
        });
        
        document.getElementById('cancelImport2Btn').addEventListener('click', () => {
          confirmModal.remove();
        });
        
        confirmModal.addEventListener('click', (e) => {
          if (e.target === confirmModal) {
            confirmModal.remove();
          }
        });
        
      } catch (error) {
        console.error('Import error:', error);
        modal.remove();
        alert('‚ùå Error importing progress:\n\n' + error.message + '\n\nMake sure you\'re using a valid progress file from Rainbow Words Trainer.');
      }
    }
    function updateBadges(){
      els.badgeRow.innerHTML = '';
      state.perLevel.forEach((lv, i)=>{
        if (lv.badgeEarned){
          const span = document.createElement('span');
          span.className = 'emoji-badge';
          span.textContent = LEVELS[i].badge || 'üèÖ';
          span.title = LEVELS[i].name + ' badge';
          els.badgeRow.appendChild(span);
        }
      });
    }
    function updatePhaseBadge(){
      // Phase badge removed - mode now shown in level button
      // This function is kept as no-op for compatibility
    }
    
    // Review mode button removed - mode now shown in level button
    function initializeStreakCounter(){
      // Create 20 segments for the streak bar
      els.streakBar.innerHTML = '';
      for (let i = 0; i < 20; i++) {
        const segment = document.createElement('div');
        segment.className = 'streak-segment';
        els.streakBar.appendChild(segment);
      }
      updateStreakCounter();
    }
    
    function updateStreakCounter(){
      if (reviewMode !== 'general') {
        els.streakCounter.classList.remove('show');
        return;
      }
      
      els.streakCounter.classList.add('show');
      // Show streak label with just "Streak:" text
      els.streakLabel.style.display = 'block';
      els.streakLabel.textContent = 'Streak:';
      
      const segments = els.streakBar.querySelectorAll('.streak-segment');
      segments.forEach((segment, index) => {
        segment.className = 'streak-segment';
        
        // Visual bar fills up to 20, but streak can go beyond
        const visualStreak = Math.min(20, reviewStreak);
        if (index < visualStreak) {
          segment.classList.add('filled');
          
          // Add special effects based on streak level
          if (reviewStreak >= 22) {
            // Rainbow chase effect: assign each segment a rainbow color that cycles
            const rainbowColors = 8; // 8 rainbow colors
            const colorIndex = index % rainbowColors;
            segment.classList.add('rainbow');
            segment.classList.add(`rainbow-${colorIndex}`);
          } else if (reviewStreak >= 20) {
            segment.classList.add('glowing');
          }
        }
      });
    }
    
    function updateProgressBars(){
      // Show/hide streak counter based on review mode
      updateStreakCounter();
      
      // Hide status bars when in general review mode
      if (reviewMode === 'general') {
        // Hide the entire progress section
        document.querySelector('.progress').style.display = 'none';
        els.statLearned.textContent = '';
        // Hide Reset Level button in All Known Words mode
        const resetBtn = document.getElementById('resetLevelBtn');
        if (resetBtn) resetBtn.style.display = 'none';
        return;
      } else {
        // Show the progress section when not in general review mode
        document.querySelector('.progress').style.display = 'flex';
        // Show Reset Level button in normal level mode
        const resetBtn = document.getElementById('resetLevelBtn');
        if (resetBtn) resetBtn.style.display = 'block';
      }

      const total = Math.max(1, words().length);
      const learned = masteredCount();
      
      // Determine which progress bar to show based on phase and mastery status
      if (phase === 'review') {
        // Review phase: show "Review Progress"
        els.progressLabel.textContent = 'Review Progress';
        els.progressBar.title = 'Review session progress';
        
        let pct = 0;
        if (reviewSessionQueue.length > 0) {
          pct = (reviewSessionPosition / reviewSessionQueue.length) * 100;
        }
        els.progressFill.style.width = pct.toFixed(2) + '%';
        
      } else if (phase === 'final') {
        // Test phase: show "Test Progress"
        els.progressLabel.textContent = 'Test Progress';
        els.progressBar.title = 'Test progress';
        
        let pct = 0;
        if (finalQueue.length > 0) {
          pct = (finalPosition / finalQueue.length) * 100;
        }
        els.progressFill.style.width = pct.toFixed(2) + '%';
        
      } else if (phase === 'postreview') {
        // Post-review phase: show "Review Progress"
        els.progressLabel.textContent = 'Review Progress';
        els.progressBar.title = 'Quick review progress';
        
        let pct = 0;
        if (reviewQueue.length > 0) {
          pct = (1 - (reviewQueue.length / reviewQueue._initialLen)) * 100;
        }
        els.progressFill.style.width = pct.toFixed(2) + '%';
        
      } else {
        // Study phase: show level-specific progress
        const lvl = LEVELS[levelIdx];
        els.progressLabel.textContent = 'Level Progress';
        els.progressBar.title = 'Mastery across the set';
        els.progressFill.style.width = ((learned/total)*100).toFixed(2) + '%';
      }

      // Show color name in the learned stat
      const lvl = LEVELS[levelIdx];
      els.statLearned.textContent = `${lvl.name} Words Learned: ${learned}/${total}`;
    }
    function setWord(text){
      els.word.textContent = text;
      updateProgressBars();
    }

    // ======= PICKING =======
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]] } return arr; }
    
    function hasTrickyWordsInPool(allWords) {
      return allWords.some(w => w.word.tricky);
    }
    
    function computeWeight(w, isFromPreviousLevel = false, prevLevelDistance = 0, hasTrickyWords = false){ 
      // Handle backward compatibility for new fields
      const lastSeen = w.lastSeenTimestamp || null;
      const daysSinceLastSeen = getDaysSince(lastSeen);
      
      // Base weight calculation
      let base = 1 + (w.wrong || 0) * WRONG_FACTOR - (w.streak || 0);
      
      if (reviewMode === 'current') {
        // TARGET DISTRIBUTION: 70% current / 15% tricky / 15% mastered (or 80/20 if no tricky)
        if (!isFromPreviousLevel) {
          // Current level: 70% or 80% of distribution
          base += 25; // Strong base boost for current level
          const timeBoost = Math.min(daysSinceLastSeen * 0.8, 10);
          base += timeBoost;
          if (w.tricky) base += 8; // Tricky current level words get extra boost
        } else {
          // Previous level: recency-weighted distribution
          const recencyMultiplier = Math.max(0.2, 1 - (prevLevelDistance * 0.2));
          
          if (w.tricky) {
            // Tricky words: target 15% of distribution
            base += 12 * recencyMultiplier;
            const timeBoost = Math.min(daysSinceLastSeen * 0.8, 8) * recencyMultiplier;
            base += timeBoost;
          } else if (w.mastered) {
            // Mastered words: target 15% (or 20% if no tricky words)
            const masteredBoost = hasTrickyWords ? 5 : 7; // Higher if no tricky words
            base += masteredBoost * recencyMultiplier;
            const timeBoost = Math.min(daysSinceLastSeen * 0.5, 5) * recencyMultiplier;
            base += timeBoost;
          } else {
            // Unmastered non-tricky words from previous levels: minimal weight
            base += 2 * recencyMultiplier;
            const timeBoost = Math.min(daysSinceLastSeen * 0.4, 3) * recencyMultiplier;
            base += timeBoost;
          }
        }
      } else {
        // GENERAL REVIEW: Enhanced tricky word priority for retention
        const timeBoost = Math.min(daysSinceLastSeen * 0.8, 8);
        base += timeBoost;
        
        // Enhanced tricky word priority in general review mode
        if (w.tricky) {
          base += 5; // Much higher boost for tricky words in review mode
        }
        
        // Slight boost for words that haven't been seen recently
        if (daysSinceLastSeen >= 3) {
          base += 2;
        }
      }
      
      return Math.max(MIN_WEIGHT, base); 
    }
    
    // Removed trickyRatio function - now using unified weight system

    function pickWeightedIndex(indices){
      const ws = words();
      let pool = indices.filter(i => !history.includes(i) || indices.length <= HISTORY_BLOCK);
      if (!pool.length) pool = indices.slice();
      let total = 0;
      const weights = pool.map(i=>{ const w=computeWeight(ws[i]); total+=w; return w; });
      let r = Math.random()*total;
      for (let k=0;k<pool.length;k++){ r -= weights[k]; if (r<=0) return pool[k]; }
      return pool[pool.length-1];
    }

    function ensureFirstPass(){
      if (!firstPassQueue.length){
        firstPassQueue = shuffle(words().map((_,i)=>i));
      }
    }
    function pushHistory(idx){
      history.push(idx);
      if (history.length > HISTORY_BLOCK) history.shift();
    }

    function nextWord(){
      console.log('nextWord called', { phase, wordsCount: words().length, firstPassQueueLength: firstPassQueue.length, reviewMode });
      
      if (phase === 'study' && reviewMode === 'general') {
        // GENERAL REVIEW MODE: Only use unified pool system for all mastered words
        const selectedWord = pickFromUnifiedPool();
        if (selectedWord) {
          // Handle cross-level words with special index format
          if (selectedWord.isFromPreviousLevel) {
            currentIndex = -(selectedWord.levelIdx * 1000 + selectedWord.wordIdx);
            // Update last seen timestamp for cross-level word
            selectedWord.word.lastSeenTimestamp = new Date();
          } else {
            currentIndex = selectedWord.wordIdx;
            pushHistory(selectedWord.wordIdx);
            onWordShown(selectedWord.wordIdx);
          }
          setWord(selectedWord.word.text);
          saveState(); return;
        }
        
        // If no words available, show message
        setWord('No mastered words available for review.');
        return;
      }

      if (!words().length){ setWord('No words in this level.'); return; }

      if (phase === 'study'){
        // Cross-level review is now handled by unified pool system
        // If all mastered ‚Üí prefinal (but NOT in general review mode)
        if (reviewMode !== 'general' && allMasteredInLevel()){
          phase = 'prefinal';
          updatePhaseBadge();
          updateProgressBars(); // Update progress bar to show 100% before modal
          openPreFinal();
          saveState();
          return;
        }

        // First pass: every word once before any repeats
        ensureFirstPass();
        if (firstPassQueue.length){
          const idx = firstPassQueue.shift();
          currentIndex = idx; pushHistory(idx);
          onWordShown(idx);
          setWord(words()[idx].text);
          saveState(); return;
        }

        // NEW: Priority for words not seen in 2+ days
        const dueForReview = words()
          .map((w, i) => {
            const lastSeen = w.lastSeenTimestamp || null;
            const days = getDaysSince(lastSeen);
            return (days >= REVIEW_THRESHOLD_DAYS && !w.mastered) ? i : -1;
          })
          .filter(i => i >= 0);
          
        if (dueForReview.length) {
          const idx = pickWeightedIndex(dueForReview);
          currentIndex = idx; pushHistory(idx);
          onWordShown(idx);
          setWord(words()[idx].text);
          saveState(); return;
        }

        // NEW: Check retry queue before cooldown
        if (retryQueue.length > 0) {
          const retry = retryQueue[0];
          if (retry.attemptsLeft <= 0) {
            retryQueue.shift();
            currentIndex = retry.wordIdx;
            pushHistory(retry.wordIdx);
            onWordShown(retry.wordIdx);
            setWord(words()[retry.wordIdx].text);
            saveState(); return;
          }
        }

        // After a miss, force one known word (streak >= 2) before another tricky/unknown
        if (cooldownNextKnown > 0){
          const known = words().map((w,i)=> (w.streak>=2 ? i : -1)).filter(i=>i>=0);
          if (known.length){
            const idx = pickWeightedIndex(known);
            currentIndex = idx; pushHistory(idx);
            onWordShown(idx);
            setWord(words()[idx].text);
            cooldownNextKnown = 0;
            
            // Decrement retry counter
            if (retryQueue.length > 0) {
              retryQueue[0].attemptsLeft--;
            }
            
            saveState(); return;
          }
          // if no known available, fall through
          cooldownNextKnown = 0;
        }

        // Use unified weighted pool system (replaces all the old percentage-based logic)
        const selectedWord = pickFromUnifiedPool();
        if (selectedWord) {
          // Handle cross-level words with special index format
          if (selectedWord.isFromPreviousLevel) {
            currentIndex = -(selectedWord.levelIdx * 1000 + selectedWord.wordIdx);
            // Update last seen timestamp for cross-level word
            selectedWord.word.lastSeenTimestamp = new Date();
          } else {
            currentIndex = selectedWord.wordIdx;
            pushHistory(selectedWord.wordIdx);
            onWordShown(selectedWord.wordIdx);
          }
          setWord(selectedWord.word.text);
          saveState(); return;
        }

        // Fallback to old system if unified pool fails
        const allIndices = words().map((_,i)=>i);
        if (allIndices.length === 0) {
          setWord('No words available in this level.');
          return;
        }
        const idx = pickWeightedIndex(allIndices);
        currentIndex = idx; pushHistory(idx);
        onWordShown(idx);
        setWord(words()[idx].text);
        saveState(); return;

      } else if (phase === 'review'){
        if (!reviewSessionQueue.length){
          // Create review session: each word appears once (first review is simple)
          reviewSessionQueue = [];
          words().forEach((_, i) => {
            reviewSessionQueue.push(i); // Each word appears once
          });
          reviewSessionQueue = shuffle(reviewSessionQueue);
          reviewSessionPosition = 0;
          reviewSessionResults = [];
        }
        if (reviewSessionPosition >= reviewSessionQueue.length){
          console.log('Review session complete, calling endReviewSessionAndShowResults');
          endReviewSessionAndShowResults();
          return;
        }
        const idx = reviewSessionQueue[reviewSessionPosition];
        currentIndex = idx; setWord(words()[idx].text);
        saveState(); return;

      } else if (phase === 'final'){
        if (!finalQueue.length){
          finalQueue = shuffle(words().map((_,i)=>i)); // all words once
          finalPosition = 0;
          testResults = [];
        }
        if (finalPosition >= finalQueue.length){
          endTestAndShowResults();
          return;
        }
        const idx = finalQueue[finalPosition];
        currentIndex = idx; setWord(words()[idx].text);
        saveState(); return;

      } else if (phase === 'postreview'){
        if (!reviewQueue.length){
          const canRetest = missedFromTest.every(i => words()[i].streak >= 1);
          showTestResultsOverlay(false, canRetest);
          return;
        }
        const idx = reviewQueue.shift();
        currentIndex = idx; setWord(words()[idx].text);
        saveState(); return;

      } else if (phase === 'prefinal') {
        // Don't show any word when in prefinal phase - the modal should handle this
        return;
      } else {
        setWord('Great work! Ready for your test?');
      }
    }

    // ======= EVENTS =======
    function markRight(){
      // Handle cross-level words
      if (currentIndex < 0) {
        const crossLevelIdx = Math.abs(currentIndex);
        const crossLevelIdx_level = Math.floor(crossLevelIdx / 1000);
        const crossLevelIdx_word = crossLevelIdx % 1000;
        const w = state.perLevel[crossLevelIdx_level].words[crossLevelIdx_word];
        w.seen++; seenTotal++; w.correct++; w.streak++;
        
        // Check mastery for cross-level word
        if (!w.mastered) checkMastery(w);
        if (w.streak >= TRICKY_REMOVE_AFTER_STREAK) w.tricky = false;
        
        // Update streak counter for general review mode
        if (reviewMode === 'general') {
          reviewStreak = Math.min(22, reviewStreak + 1); // Cap at 22 to maintain rainbow challenge
        }
        
        saveState(); nextWord();
        return;
      }
      
      const w = words()[currentIndex];
      if (!w) {
        console.error('Word not found at index:', currentIndex);
        return;
      }
      w.seen++; seenTotal++; w.correct++; w.streak++;
      
      // Track mastery dates for enhanced mastery logic
      if (!w.masteryDates) w.masteryDates = [];
      if (Array.isArray(w.masteryDates)) {
        w.masteryDates.push(new Date());
      }
      
      // Use enhanced mastery check
      if (!w.mastered) checkMastery(w);
      
      if (w.streak >= TRICKY_REMOVE_AFTER_STREAK) w.tricky = false;

      // Update streak counter for general review mode
      if (reviewMode === 'general') {
        reviewStreak = Math.min(22, reviewStreak + 1); // Cap at 22 to maintain rainbow challenge
      }

      if (phase === 'review'){
        reviewSessionResults.push({idx: currentIndex, correct:true});
        reviewSessionPosition++; // always advance in review session
      } else if (phase === 'final'){
        testResults.push({idx: currentIndex, correct:true});
        finalPosition++; // always advance in test
      }
      saveState(); nextWord();
    }

    function markWrong(){
      // Handle cross-level words
      if (currentIndex < 0) {
        const crossLevelIdx = Math.abs(currentIndex);
        const crossLevelIdx_level = Math.floor(crossLevelIdx / 1000);
        const crossLevelIdx_word = crossLevelIdx % 1000;
        const w = state.perLevel[crossLevelIdx_level].words[crossLevelIdx_word];
        w.seen++; seenTotal++; w.wrong++; w.streak = 0;
        
        // Clear mastery dates on wrong answer
        w.masteryDates = [];
        if (w.wrong >= TRICKY_ADD_AFTER_WRONGS) w.tricky = true;
        
        // Update streak counter for general review mode (dip down)
        if (reviewMode === 'general') {
          reviewStreak = Math.max(0, reviewStreak - 1);
        }
        
        saveState(); nextWord();
        return;
      }
      
      const w = words()[currentIndex];
      if (!w) {
        console.error('Word not found at index:', currentIndex);
        return;
      }
      
      // Clear mastery dates on wrong answer
      w.masteryDates = [];
      
      if (w.wrong >= TRICKY_ADD_AFTER_WRONGS) w.tricky = true;

      // Update streak counter for general review mode (dip down)
      if (reviewMode === 'general') {
        reviewStreak = Math.max(0, reviewStreak - 1);
      }

      // Add to retry queue for enhanced retry logic
      if (phase === 'study') {
        retryQueue.push({
          wordIdx: currentIndex,
          attemptsLeft: RETRY_DELAY
        });
        cooldownNextKnown = 1;
      }

      if (phase === 'review'){
        reviewSessionResults.push({idx: currentIndex, correct:false});
        reviewSessionPosition++; // still advance in review session
      } else if (phase === 'final'){
        testResults.push({idx: currentIndex, correct:false});
        finalPosition++; // still advance in test
      }
      saveState(); nextWord();
    }

    // ======= MODALS / TEST / REVIEW =======
    function openPreFinal(){
      const lvl = LEVELS[levelIdx];
      
      // Show both review and retest options initially
    document.querySelector('#preFinalOverlay h2').textContent = 'Nice Job!';
      document.querySelector('#preFinalOverlay .muted').innerHTML = 'You\'ve already earned your <b id="badgeName">' + lvl.name + '</b> badge!';
      
      // Show both options from the start
      const btnRow = document.querySelector('#preFinalOverlay .btn-row');
      btnRow.innerHTML = `
        <button id="startReviewBtn">Keep Practicing</button>
        <button id="startFinalBtn">Start the Test</button>
      `;
      
      // Add event listeners
      document.getElementById('startReviewBtn').addEventListener('click', ()=>{
        closePreFinal(); phase='review'; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; updatePhaseBadge(); saveState(); nextWord();
      });
      
      document.getElementById('startFinalBtn').addEventListener('click', ()=>{
        closePreFinal(); phase='final'; finalQueue=[]; finalPosition=0; testResults=[]; updatePhaseBadge(); saveState(); nextWord();
      });
      
      isAfterSuccessfulReview = false; // Reset the flag
      document.getElementById('preFinalOverlay').classList.add('show');
    }
    function closePreFinal(){ document.getElementById('preFinalOverlay').classList.remove('show'); }
    
    function endReviewSessionAndShowResults(){
      const total = reviewSessionResults.length;
      const correct = reviewSessionResults.filter(r=>r.correct).length;
      const percent = Math.round((correct/total)*100);
      
      console.log('Review session ended', { total, correct, percent });
      
      if (percent === 100){
        // Perfect review session - now offer the test
        console.log('Perfect review, calling showReviewSuccessModal');
        phase = 'study'; // Reset phase to study so we can show the modal
        updatePhaseBadge();
        saveState();
        showReviewSuccessModal();
      } else {
        // Some words were missed - restart review with special sequence
        console.log('Review failed, restarting review with missed words prioritized');
        missedFromReview = reviewSessionResults.filter(r=>!r.correct).map(r=>r.idx);
        missedFromReview.forEach(i => {
          const word = words()[i];
          word.tricky = true;
          word.streak = 0; // Reset streak for missed words
        });
        
        showReviewFailedModal(percent, correct, total);
      }
    }
    
    function resetPreFinalModal(){
      // Reset the modal to its original state
      document.querySelector('#preFinalOverlay h2').textContent = 'Looks like you know these words!';
      document.querySelector('#preFinalOverlay .muted').innerHTML = 'Let\'s do a quick review to make sure you really know them, then you can earn your <b id="badgeName">Red</b> badge!';
      document.querySelector('#preFinalOverlay .row .muted').textContent = 'The review shows each word once in random order. Get them all right to unlock the test!';
      
      // Reset the button row to original state
      const btnRow = document.querySelector('#preFinalOverlay .btn-row');
      btnRow.innerHTML = `
        <button id="startReviewBtn">Start Review</button>
      `;
      
      // Re-add event listener for the original button
      document.getElementById('startReviewBtn').addEventListener('click', ()=>{
        closePreFinal(); phase='review'; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; updatePhaseBadge(); saveState(); nextWord();
      });
    }
    
    function showReviewSuccessModal(){
      console.log('showReviewSuccessModal called');
      const lvl = LEVELS[levelIdx];
      
      // Update the modal content to show both review and test options
      document.querySelector('#preFinalOverlay h2').textContent = 'Looks like you\'ve got these words!';
      document.querySelector('#preFinalOverlay .muted').innerHTML = 'Want to review or test yourself? You can earn your <b id="badgeName">' + lvl.name + '</b> badge!';
      document.querySelector('#preFinalOverlay .row .muted').textContent = 'Choose what you\'d like to do:';
      
      // Show both options
      const btnRow = document.querySelector('#preFinalOverlay .btn-row');
      btnRow.innerHTML = `
        <button id="startReviewBtn">Review</button>
        <button id="startFinalBtn">Test</button>
      `;
      
      // Add event listeners
      document.getElementById('startReviewBtn').addEventListener('click', ()=>{
        closePreFinal(); phase='review'; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; updatePhaseBadge(); saveState(); nextWord();
      });
      
      document.getElementById('startFinalBtn').addEventListener('click', ()=>{
        closePreFinal(); phase='final'; finalQueue=[]; finalPosition=0; testResults=[]; updatePhaseBadge(); saveState(); nextWord();
      });
      
      isAfterSuccessfulReview = true; // Set the flag
      console.log('About to show preFinalOverlay');
      document.getElementById('preFinalOverlay').classList.add('show');
      console.log('preFinalOverlay should be visible now');
    }
    
    function showReviewFailedModal(percent, correct, total){
      // Create a temporary modal for review failure
      const modal = document.createElement('div');
      modal.className = 'overlay show';
      modal.innerHTML = `
        <div class="card">
          <h2>Let's Try Again! üéØ</h2>
          <div class="muted">You got ${correct}/${total} correct (${percent}%)</div>
          <div style="margin-top:8px">
            <div class="muted">Let's review these words again. We'll focus on the tricky ones!</div>
          </div>
          <div class="btn-row">
            <button id="restartReviewBtn">Start Review</button>
          </div>
        </div>
      `;
      document.body.appendChild(modal);
      
      // Add event listener to restart review
      document.getElementById('restartReviewBtn').addEventListener('click', () => {
        modal.remove();
        startReviewWithMissedWordsPriority();
      });
    }
    
    function startReviewWithMissedWordsPriority(){
      // Build review queue: missed words at beginning (1x), all correct words (1x), missed words at end (1x)
      const allWordIndices = words().map((w, i) => i);
      const correctIndices = allWordIndices.filter(i => !missedFromReview.includes(i));
      
      reviewSessionQueue = [];
      
      // Add missed words once at the beginning
      missedFromReview.forEach(i => {
        reviewSessionQueue.push(i);
      });
      
      // Add correct words once
      correctIndices.forEach(i => {
        reviewSessionQueue.push(i);
      });
      
      // Add missed words once more at the end
      missedFromReview.forEach(i => {
        reviewSessionQueue.push(i);
      });
      
      // Shuffle for variety
      reviewSessionQueue = shuffle(reviewSessionQueue);
      reviewSessionPosition = 0;
      reviewSessionResults = [];
      phase = 'review';
      updatePhaseBadge();
      saveState();
      nextWord();
    }

    function endTestAndShowResults(){
      const total = testResults.length || words().length;
      const correct = testResults.filter(r=>r.correct).length;
      const percent = Math.round((correct/total)*100);
      missedFromTest = testResults.filter(r=>!r.correct).map(r=>r.idx);

      if (percent === 100){
        const lvl = LEVELS[levelIdx];
        const wasAlreadyEarned = currentLevel().badgeEarned;
        currentLevel().badgeEarned = true;
        updateBadges();
        document.getElementById('successTitle').textContent = `${lvl.name} Level Mastered!`;
        document.getElementById('successText').textContent = `Perfect score, ${studentName || 'great job'}!`;
        document.getElementById('earnedBadge').textContent = lvl.badge || 'üèÖ';
        document.getElementById('success').classList.add('show');

        // Show celebration animation for all perfect test scores
        showBadgeCelebration(lvl.badge);

        phase = 'study';
        finalQueue = []; finalPosition = 0;
        firstPassQueue = []; history = [];
        saveState(); return;
      }

      // Mark missed words as tricky and return to study mode
      missedFromTest.forEach(i => {
        const word = words()[i];
        word.tricky = true;
        word.streak = 0; // Reset streak for missed words
      });

      showTestResultsOverlay(true, true); // Allow retest after failed test
      phase = 'study'; // Return to study mode instead of review
      updatePhaseBadge(); saveState();
    }

    function showTestResultsOverlay(showStartButtons, canRetest){
      const total = testResults.length || words().length;
      const correct = testResults.filter(r=>r.correct).length;
      const percent = Math.round((correct/total)*100);
      
      // Friendly messaging based on performance
      if (percent === 100) {
        document.getElementById('testResultTitle').textContent = 'Perfect Score! üéâ';
        document.getElementById('testResultSub').textContent = `Amazing work, ${studentName || 'you'}! ${correct}/${total} correct!`;
        document.getElementById('missedList').textContent = '';
      } else if (percent >= 80) {
        document.getElementById('testResultTitle').textContent = 'Great Job! üåü';
        document.getElementById('testResultSub').textContent = `You're doing awesome! ${correct}/${total} correct (${percent}%)`;
        if (missedFromTest.length){
          const list = missedFromTest.map(i=>words()[i].text).join(', ');
          document.getElementById('missedList').textContent = `Let's practice these: ${list}`;
        } else {
          document.getElementById('missedList').textContent = '';
        }
      } else if (percent >= 60) {
        document.getElementById('testResultTitle').textContent = 'Nice Try! üí™';
        document.getElementById('testResultSub').textContent = `You're getting there! ${correct}/${total} correct (${percent}%)`;
        if (missedFromTest.length){
          const list = missedFromTest.map(i=>words()[i].text).join(', ');
          document.getElementById('missedList').textContent = `Let's practice these together: ${list}`;
        } else {
          document.getElementById('missedList').textContent = '';
        }
      } else {
        document.getElementById('testResultTitle').textContent = 'So Close! üå±';
        document.getElementById('testResultSub').textContent = `You can do this! Let's practice those tricky ones! ${correct}/${total} correct (${percent}%)`;
        if (missedFromTest.length){
          const list = missedFromTest.map(i=>words()[i].text).join(', ');
          document.getElementById('missedList').textContent = `We'll practice: ${list}`;
        } else {
          document.getElementById('missedList').textContent = '';
        }
      }
      
      document.getElementById('retestBtn').disabled = !canRetest;
      document.getElementById('startQuickReviewBtn').style.display = showStartButtons ? 'inline-block' : 'none';
      document.getElementById('testResultOverlay').classList.add('show');
    }
    function closeTestResultsOverlay(){ document.getElementById('testResultOverlay').classList.remove('show'); }

    // ======= LEVELS / STUDENT =======
    function openLevelPicker(){
      populateLevelGrid();
      document.getElementById('levelOverlay').classList.add('show');
    }
    function closeLevelPicker(){ document.getElementById('levelOverlay').classList.remove('show'); }
    function populateLevelGrid(){
      const grid = document.getElementById('levelGrid'); grid.innerHTML = '';
      LEVELS.forEach((lvl, i)=>{
        const btn = document.createElement('button');
        btn.className = 'level-btn';
        btn.innerHTML = `
          <div class="level-dot" style="background:${lvl.color}"></div>
          <span>${lvl.name}</span>
          <small>${(state.perLevel[i].words||[]).length} words</small>
        `;
        btn.addEventListener('click', ()=>{ switchLevel(i); closeLevelPicker(); });
        grid.appendChild(btn);
      });
      
      // Add "All Known Words" option as the 9th button
      const allMasteredCount = state.perLevel.reduce((sum, level) => {
        return sum + level.words.filter(w => w.mastered).length;
      }, 0);
      
      const allWordsBtn = document.createElement('button');
      allWordsBtn.className = 'level-btn';
      allWordsBtn.innerHTML = `
        <div class="level-dot" style="background:linear-gradient(45deg, #ef4444, #f97316, #eab308, #22c55e, #3b82f6, #a855f7, #ec4899, #38bdf8); background-size:200% 200%; animation:rainbowFlow 3s ease infinite;"></div>
        <span>All Known Words</span>
        <small>${allMasteredCount} words</small>
      `;
      allWordsBtn.addEventListener('click', ()=>{
        reviewMode = 'general';
        phase = 'study';
        reviewStreak = 10; // Reset streak to middle when entering All Known Words mode
        updateHeader();
        updatePhaseBadge();
        saveState();
        closeLevelPicker();
        nextWord();
      });
      grid.appendChild(allWordsBtn);
    }
    function syncWordsWithConfig(li){
      const cfg = LEVELS[li].words || [];
      const per = state.perLevel[li];
      const have = new Set(per.words.map(w=>w.text));
      per.words = per.words.filter(w => cfg.includes(w.text));
      cfg.forEach(t=>{
        if (!have.has(t)){
          per.words.push({
            text:t, seen:0, correct:0, wrong:0, streak:0, mastered:false, tricky:false,
            lastSeenTimestamp:null, masteryDates:[], sessionsSeen:0, currentSessionSeen:false
          });
        }
      });
    }
    function switchLevel(newIdx){
      levelIdx = newIdx;
      reviewMode = 'current'; // Switch back to current level mode
      phase = 'study';
      finalQueue = []; finalPosition = 0;
      firstPassQueue = []; history = [];
      testResults = []; missedFromTest = []; reviewQueue = [];
      reviewSessionQueue = []; reviewSessionPosition = 0; reviewSessionResults = [];
      missedFromReview = [];
      cooldownNextKnown = 0;
      retryQueue = [];
      endSession(); // Clear session tracking
      syncWordsWithConfig(newIdx);
      updateHeader(); updatePhaseBadge(); updateBadges(); saveState(); nextWord();
    }

    // ======= BUTTONS / KEYS =======
    els.zoneRight.addEventListener('click', markRight);
    els.zoneWrong.addEventListener('click', markWrong);

    // Only W/R keys; disabled while any modal is open or an input is focused
    function anyOverlayOpen(){
      return [...document.querySelectorAll('.overlay')].some(o=>o.classList.contains('show'));
    }
    document.addEventListener('keydown', (e)=>{
      const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
      if (tag === 'input' || anyOverlayOpen()) return; // don't capture while typing or in modals
      const k = e.key.toLowerCase();
      if (k === 'w'){ e.preventDefault(); markWrong(); }
      if (k === 'r'){ e.preventDefault(); markRight(); }
    });

    els.resetLevelBtn.addEventListener('click', ()=>{
      if (!confirm('Reset progress for this level?')) return;
      state.perLevel[levelIdx].words.forEach(w=>{ 
        w.seen=0; w.correct=0; w.wrong=0; w.streak=0; w.mastered=false; w.tricky=false;
        w.lastSeenTimestamp=null; w.masteryDates=[]; w.sessionsSeen=0; w.currentSessionSeen=false;
      });
      phase='study'; finalQueue=[]; finalPosition=0; firstPassQueue=[]; history=[]; testResults=[]; missedFromTest=[]; reviewQueue=[]; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; missedFromReview=[]; cooldownNextKnown=0; retryQueue=[];
      endSession();
      saveState(); updateProgressBars(); nextWord();
    });

    if (els.resetAllBtn) {
      els.resetAllBtn.addEventListener('click', (e)=>{
        console.log('Reset All button clicked!');
        e.preventDefault();
        e.stopPropagation();
        
        // Close profile modal first
        closeProfile();
        
        // Create custom confirmation modal
        const confirmModal = document.createElement('div');
        confirmModal.className = 'overlay show';
        confirmModal.style.zIndex = '50';
        confirmModal.innerHTML = `
          <div class="card">
            <h2>‚ö†Ô∏è Reset ALL Progress?</h2>
            <div class="muted" style="margin-top:12px;">This will delete:</div>
            <ul style="margin:12px 0; padding-left:20px; color:var(--muted); font-size:14px;">
              <li>All progress across all levels</li>
              <li>All earned badges</li>
              <li>Student name</li>
              <li>All word mastery data</li>
            </ul>
            <div style="margin-top:12px; padding:12px; background:rgba(239,68,68,0.08); border-radius:8px; border:1px solid rgba(239,68,68,0.2);">
              <div style="font-size:12px; color:#ef4444; font-weight:700;">This cannot be undone!</div>
            </div>
            <div class="btn-row" style="margin-top:16px;">
              <button id="confirmResetBtn" style="background:#ef4444; color:white; border:1px solid #ef4444;">Reset Everything</button>
              <button id="cancelResetBtn" class="ghost">Cancel</button>
            </div>
          </div>
        `;
        
        document.body.appendChild(confirmModal);
        
        document.getElementById('confirmResetBtn').addEventListener('click', () => {
          console.log('User confirmed reset');
          confirmModal.remove();
          
          console.log('Starting reset...');
          state = makeFreshState();
          levelIdx = 0; phase='study'; finalQueue=[]; finalPosition=0; firstPassQueue=[]; history=[];
          seenTotal = 0; testResults=[]; missedFromTest=[]; reviewQueue=[]; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; missedFromReview=[]; studentName=''; cooldownNextKnown=0; retryQueue=[];
          endSession();
          console.log('Saving state...');
          saveState(); 
          console.log('Updating UI...');
          updateHeader(); updateBadges(); updatePhaseBadge(); updateProgressBars();
          console.log('Opening welcome...');
          openWelcome();
          console.log('Reset complete!');
        });
        
        document.getElementById('cancelResetBtn').addEventListener('click', () => {
          console.log('User cancelled reset');
          confirmModal.remove();
        });
        
        confirmModal.addEventListener('click', (e) => {
          if (e.target === confirmModal) {
            console.log('User cancelled reset (clicked outside)');
            confirmModal.remove();
          }
        });
      });
    } else {
      console.error('Reset All Button not found!');
    }

    // Review mode button removed - mode now switched via level picker
    
    els.changeLevelBtn.addEventListener('click', ()=>{
      if (!studentName) { openWelcome(); return; }
      openLevelPicker();
    });
    els.closeLevelBtn.addEventListener('click', closeLevelPicker);

    document.getElementById('startReviewBtn').addEventListener('click', ()=>{
      closePreFinal(); phase='review'; reviewSessionQueue=[]; reviewSessionPosition=0; reviewSessionResults=[]; updatePhaseBadge(); saveState(); nextWord();
    });
    

    document.getElementById('startQuickReviewBtn').addEventListener('click', ()=>{
      closeTestResultsOverlay(); 
      phase='study'; // Stay in study mode
      updatePhaseBadge(); 
      saveState(); 
      nextWord(); // Start practicing with tricky words interspersed
    });
    document.getElementById('retestBtn').addEventListener('click', ()=>{
      closeTestResultsOverlay(); phase='final'; finalQueue=[]; finalPosition=0; testResults=[]; updatePhaseBadge(); saveState(); nextWord();
    });

    document.getElementById('reviewAgainBtn').addEventListener('click', ()=>{
      document.getElementById('success').classList.remove('show');
      hideBadgeCelebration();
      // Go to next level
      if (levelIdx < LEVELS.length - 1) {
        switchLevel(levelIdx + 1);
      } else {
        // If at last level, just open level picker
        openLevelPicker();
      }
    });
    document.getElementById('pickNextLevelBtn').addEventListener('click', ()=>{
      document.getElementById('success').classList.remove('show');
      hideBadgeCelebration();
      openLevelPicker();
    });

    // Profile functionality
    // Profile button click handler
    document.getElementById('profileBtn').addEventListener('click', () => {
      if (studentName) {
        openProfile();
      }
    });
    
    els.closeProfileBtn.addEventListener('click', closeProfile);
    els.exportProgressBtn.addEventListener('click', exportProgress);
    els.importProgressBtn.addEventListener('click', () => {
      closeProfile();
      importProgress();
    });
    
    // Close profile when clicking overlay
    els.profileOverlay.addEventListener('click', (e) => {
      if (e.target === els.profileOverlay) {
        closeProfile();
      }
    });

    // Welcome / student name (first step)
    function openWelcome(){
      els.welcomeOverlay.classList.add('show');
      els.studentNameInput.focus();
    }
    function closeWelcome(){ els.welcomeOverlay.classList.remove('show'); }
    document.getElementById('saveStudentBtn').addEventListener('click', ()=>{
      const v = (els.studentNameInput.value || '').trim();
      
      if (!v) {
        // Show error modal if no name entered
        const errorModal = document.createElement('div');
        errorModal.className = 'overlay show';
        errorModal.style.zIndex = '50';
        errorModal.innerHTML = `
          <div class="card">
            <h2>‚ö†Ô∏è Student Name Required</h2>
            <div class="muted" style="margin-top:12px;">Please enter a student name to continue.</div>
            <div class="btn-row" style="margin-top:16px;">
              <button id="closeErrorBtn" style="background:var(--accent); color:#0f1115; border:1px solid var(--accent);">OK</button>
            </div>
          </div>
        `;
        document.body.appendChild(errorModal);
        
        document.getElementById('closeErrorBtn').addEventListener('click', () => {
          errorModal.remove();
          els.studentNameInput.focus();
        });
        
        errorModal.addEventListener('click', (e) => {
          if (e.target === errorModal) {
            errorModal.remove();
            els.studentNameInput.focus();
          }
        });
        return;
      }
      
      studentName = v;
      
      // Default to current level mode for new users
      reviewMode = 'current';
      
      updateHeader(); saveState(); closeWelcome(); openLevelPicker();
      nextWord(); // Start showing words after level picker
    });
    
    document.getElementById('importFromWelcomeBtn').addEventListener('click', ()=>{
      closeWelcome();
      importProgress(true); // true = opened from welcome modal
    });

    // ======= WELCOME BACK =======
    function showWelcomeBack(){
      // Find the lowest unpassed level
      let lowestUnpassedLevel = -1;
      for (let i = 0; i < LEVELS.length; i++) {
        const levelData = state.perLevel[i];
        const masteredCount = levelData.words.filter(w => w.mastered).length;
        const totalCount = levelData.words.length;
        if (masteredCount < totalCount) {
          lowestUnpassedLevel = i;
          break;
        }
      }
      
      // If all levels are passed, start with the last level
      if (lowestUnpassedLevel === -1) {
        lowestUnpassedLevel = LEVELS.length - 1;
      }
      
      // Create welcome back modal
      const modal = document.createElement('div');
      modal.className = 'overlay show';
      modal.innerHTML = `
        <div class="card">
          <h2>Welcome back, ${studentName}! üëã</h2>
          <div class="muted">Ready to continue your sight words journey?</div>
          
          <div style="margin-top:20px; display:flex; gap:12px; flex-direction:column;">
            <button id="continueCurrentBtn" style="background:var(--panel); color:var(--fg); border:1px solid rgba(255,255,255,0.10); border-radius:10px; padding:12px 16px; font-weight:700; cursor:pointer; font-size:16px; text-align:left;">
              <div style="display:flex; align-items:center; gap:12px;">
                <div style="width:20px; height:20px; border-radius:50%; background:${LEVELS[levelIdx].color}"></div>
                <div>
                  <div style="font-weight:800;">${LEVELS[levelIdx].name} Level</div>
                  <div style="font-size:12px; color:var(--muted);">${masteredCount()}/${words().length} words mastered</div>
                </div>
              </div>
            </button>
            
            <button id="pickLevelBtn" style="background:var(--panel); color:var(--fg); border:1px solid rgba(255,255,255,0.10); border-radius:10px; padding:12px 16px; font-weight:700; cursor:pointer; font-size:16px; text-align:left;">
              <div style="display:flex; align-items:center; gap:12px;">
                <div style="width:20px; height:20px; border-radius:50%; background:linear-gradient(45deg, #ef4444, #f97316, #eab308, #22c55e, #3b82f6, #a855f7, #ec4899, #38bdf8);"></div>
                <div>
                  <div style="font-weight:800;">Choose Level</div>
                  <div style="font-size:12px; color:var(--muted);">Pick any level to practice</div>
                </div>
              </div>
            </button>
          </div>
        </div>
      `;
      
      document.body.appendChild(modal);
      
      // Add event listeners
      document.getElementById('continueCurrentBtn').addEventListener('click', () => {
        modal.remove();
        // Ensure we're in current level mode and study phase
        reviewMode = 'current';
        phase = 'study';
        updateHeader();
        updatePhaseBadge();
        saveState();
        nextWord();
      });
      
      document.getElementById('pickLevelBtn').addEventListener('click', () => {
        modal.remove();
        openLevelPicker();
      });
      
      // Review all known words button removed - now accessible via level picker
      
      // Close modal when clicking overlay
      modal.addEventListener('click', (e) => {
        if (e.target === modal) {
          modal.remove();
          nextWord();
        }
      });
    }

    // ======= BOOT =======
    function boot(){
      console.log('Boot starting...', { studentName, levelIdx, phase, levelsLoaded: LEVELS.length });
      
      // Ensure state has correct number of levels
      if (!state.perLevel || state.perLevel.length !== LEVELS.length) {
        console.log('Initializing state for', LEVELS.length, 'levels');
        state = makeFreshState();
      }
      
      // Ensure per-level words match config
      state.perLevel.forEach((_, i)=>syncWordsWithConfig(i));
      
      console.log('State initialized, current level words:', words().length);

      // Reset phase if in general review mode to avoid prefinal/review phases
      if (reviewMode === 'general') {
        phase = 'study';
      }

      // Initialize streak counter
      initializeStreakCounter();

      updateHeader(); updateBadges(); updatePhaseBadge(); updateProgressBars();

      // Name and practice mode FIRST; only after both are set do we show welcome back
      if (!studentName){ 
        console.log('No student name, opening welcome');
        openWelcome(); 
      } else { 
        console.log('Student name exists, showing welcome back');
        showWelcomeBack(); 
      }
    }

    // Load words from external file, then boot
    async function loadWordsAndBoot() {
      try {
        const response = await fetch('words.json');
        if (!response.ok) {
          throw new Error('Failed to load words.json');
        }
        const data = await response.json();
        LEVELS = data.levels;
        console.log('Words loaded:', LEVELS.length, 'levels');
        boot();
      } catch (error) {
        console.error('Error loading words:', error);
        document.getElementById('wordDisplay').textContent = 'Error loading word list. Please refresh the page.';
      }
    }
    
    loadWordsAndBoot();
  })();
  </script>
</body>
</html>
